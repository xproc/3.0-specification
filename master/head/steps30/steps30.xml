<specification xmlns="http://docbook.org/ns/docbook" xmlns:cs="http://www.w3.org/XML/XProc/2006/04/components#" xmlns:e="http://www.w3.org/1999/XSL/Spec/ElementSyntax" xmlns:p="http://www.w3.org/ns/xproc" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" class="ed" version="5.0-extension w3c-xproc">
<info>
<title>XProc 3.0: Standard Step Library</title>
<w3c-shortname>xproc30-steps</w3c-shortname>
<!-- defaults to date formatted <pubdate>2014-12-18</pubdate> -->

<bibliorelation type="isformatof" xlink:href="steps30.xml">XML</bibliorelation>
<authorgroup>
  <author>
    <personname>Achim Berndzen</personname>
  </author>
  <author>
    <personname>Gerrit Imsieke</personname>
  </author>
  <author>
    <personname>Norman Walsh</personname>
  </author>
</authorgroup>

<abstract>
  <para>This specification describes the standard step vocabulary of
  <citetitle>XProc 3.0: An XML Pipeline Language</citetitle>.</para>
</abstract>

<legalnotice role="status">

<para><emphasis>This section describes the status of this document at
the time of its publication. Other documents may supersede this
document.</emphasis></para>

<para>This document is derived from
<link xlink:href="https://www.w3.org/TR/2010/REC-xproc-20100511/">XProc:
An XML Pipeline Language</link> published by the W3C. See also
<xref linkend="credits"/>.</para>
</legalnotice>
</info>

<section xml:id="introduction">
  <title>Introduction</title>

<para>This specification describes the standard, atomic XProc steps.
<!-- FIXME:
A machine-readable description of
these steps may be found in
<link xlink:href="xproc-2.0.xpl">xproc-2.0.xpl</link>.
-->
</para>

<para>The types given for options should be understood as follows:</para>
<itemizedlist>
  <listitem>
    <para>Types in the XML Schema namespace, identified as QNames with the
    <code>xs:</code> prefix, as per the XML Schema specification with one
    exception. Anywhere an <code>xs:QName</code> is specified,
    an
    <link xlink:href="https://www.w3.org/TR/xquery-30/#doc-xquery30-EQName">EQName</link>
    is allowed.</para>
  </listitem>
  <listitem>
    <para><type>XPathExpression</type>:
    As a string per <biblioref linkend="xmlschema-2"/>, including
    whitespace normalization, and the further requirement to be a
    conformant Expression per <biblioref linkend="xpath31"/>.
    </para>
  </listitem>
  <listitem>
    <para><type>XSLTMatchPattern</type>: An XSLT pattern.
    </para>
  </listitem>
  <listitem>
    <para><type>XPathSequenceType</type>: An XPath
    <link xlink:href="https://www.w3.org/TR/xpath-31/#id-types">sequence type</link>.
    </para>
  </listitem>
  <listitem>
    <para><type>ContentType</type>: A media type as defined in
    <biblioref linkend="rfc2046"/>.
    </para>
  </listitem>
  <listitem>
    <para><type>ContentTypes</type>:
    As a whitespace separated list of media types as defined in
    <biblioref linkend="rfc2046"/>.
    </para>
  </listitem>
</itemizedlist>

<para>Option values are often expressed using <link linkend="option-shortcut">the shortcut syntax</link>. In these cases,
the option shortcuts are generally treated as <link linkend="value-templates">value templates</link>. However, for options
of type <code>map()</code> or <code>array()</code>, an expression is
<emphasis>required</emphasis> (there is no non-expression string which
can ever be a legal value for a map or array). Given that every value
entered this way will have to be a value template, and consequently
every curly brace contained within the expression will have to be
escaped, values of type map or array are defined to be expressions
directly.</para>

<para>Some aspects of documents are generally unchanged by steps:</para>

<itemizedlist>
<listitem>
<para>When a step in this library produces an output document,
the base URI of the output is the base URI of the step's primary
input document unless the step's process explicitly sets an
<tag class="attribute">xml:base</tag> attribute or the step's
description explicitly states how the base URI is constructed.</para>
</listitem>
<listitem>
<para>Each step describes how it modifies the
<glossterm>document properties</glossterm> of the documents
that flow through it.</para>
<para>A great many steps indicate that they preserve some or all of
the properties of the input document. It should be noted that in some
cases the transformation performed by the step will violate the
condition associated with some property. In general, the steps cannot
know this and the pipeline author is responsible for managing the
properties with greater care in this case.
</para>
</listitem>
</itemizedlist>

<para xml:id="cv.result">Also, in this specification, several steps use this
element for result information:</para>

<e:rng-pattern name="VocabResult"/>

<para>When a step uses an XPath to compute an option value, the XPath
context is as defined in
<olink targetdoc="../xproc20/xproc20.xml" targetptr="xpath-context"/>.</para>

<para>When a step specifies a particular version of a technology,
implementations <rfc2119>must</rfc2119> implement that
version or a subsequent version that is backwards compatible with that
version. At user-option, they may implement other non-backwards
compatible versions.</para>

<section xml:id="std-required">
<title>Required Steps</title>

<para>This section describes standard steps that must be supported
by any conforming processor.</para>

<section xml:id="c.add-attribute">
<title>p:add-attribute</title>

<para>The <code>p:add-attribute</code> step adds a single attribute to
a set of matching elements. The input document specified on the
<code>source</code> is processed for matches specified by the match
pattern in the <option>match</option> option. For each of these
matches, the attribute whose name is specified by the
<option>attribute-name</option> option is set to the attribute value
specified by the <option>attribute-value</option> option.
</para>

<para>The resulting document is produced on the <code>result</code>
output port and consists of a exact copy of the input with the
exception of the matched elements. Each of the matched elements is
copied to the output with the addition of the specified attribute
with the specified value.
</para>

<p:declare-step type="p:add-attribute">
  <p:input port="source" content-types="application/xml text/xml */*+xml"/>
  <p:output port="result" content-types="application/xml"/>
  <p:option name="match" select="'/*'" as="xs:string" e:type="XSLTMatchPattern"/>
  <p:option name="attribute-name" required="true" as="xs:QName"/>
  <p:option name="attribute-prefix" as="xs:NCName"/>
  <p:option name="attribute-namespace" as="xs:anyURI"/>
  <p:option name="attribute-value" required="true" as="xs:string"/>
</p:declare-step>

<para>The value of the <option>match</option> option
<rfc2119>must</rfc2119> be an XSLTMatchPattern. <error code="C0023">It
is a <glossterm>dynamic error</glossterm> if the match pattern matches a node
which is not an element.</error></para>

<para>The value of the <option>attribute-name</option> option
<rfc2119>must</rfc2119> be a <type>QName</type>.
If the lexical value does not contain a colon, then the <tag class="attribute">attribute-namespace</tag> may be used to specify the
namespace of the attribute. In that case, the <tag class="attribute">attribute-prefix</tag> may be specified to suggest a
prefix for the attribute name. <error code="D0034">It is a
<glossterm>dynamic error</glossterm> to specify a new namespace or
prefix if the lexical value of the specified name contains a
colon.</error>
The corresponding expanded name is used to construct the attribute.</para>

<para>The value of the <option>attribute-value</option> option
<rfc2119>must</rfc2119> be a legal attribute value according to XML.</para>

<para>If an attribute with the same name as the expanded name
from the <option>attribute-name</option> option exists on the matched
element, the value specified in
the <option>attribute-value</option> option is used to set the
value of that existing attribute.  That is, the value of the
existing attribute is changed to the <option>attribute-value</option>
value. </para>

<note xml:id="note-multattr"><para>If multiple attributes need to be set on the same
element(s), the <tag>p:set-attributes</tag> step can be used to set them
all at once.</para>
</note>

<para>This step cannot be used to add namespace declarations. <error code="C0059">It is a <glossterm>dynamic error</glossterm> if the QName
value in the <option>attribute-name</option> option uses the prefix
“<literal>xmlns</literal>”
or any other prefix that resolves to the namespace name
<uri>http://www.w3.org/2000/xmlns/</uri>.
</error> Note, however, that while namespace declarations cannot be
added explicitly by this step, adding an attribute whose name is in a
namespace for which there is no namespace declaration in scope on the
matched element may result in a namespace binding being added by
<olink targetdoc="../xproc20/xproc20.xml" targetptr="namespace-fixup"/>.</para>

<para>If an attribute named
<tag class="attribute">xml:base</tag> is added or changed, the base URI
of the element <rfc2119>must</rfc2119> also be amended accordingly.</para>

<section>
<title>Document properties</title>
<para feature="add-attribute-preserves-all">All document properties are preserved.</para>
</section>
</section>
<section xml:id="c.add-xml-base">

<title>p:add-xml-base</title>

<para>The <code>p:add-xml-base</code> step exposes the base URI via
explicit <code>xml:base</code> attributes. The input document from the
<port>source</port> port is replicated to the <port>result</port> port
with <code>xml:base</code> attributes added to or corrected on each element as specified
by the options on this step.</para>

<p:declare-step type="p:add-xml-base">
   <p:input port="source" content-types="application/xml text/xml */*+xml"/>
   <p:output port="result" content-types="application/xml"/>
   <p:option name="all" select="false()" as="xs:boolean"/>
   <p:option name="relative" select="true()" as="xs:boolean"/>
</p:declare-step>

 <para>The value of the <option>all</option> option
<rfc2119>must</rfc2119> be a boolean.</para>

 <para>The value of the <option>relative</option> option
<rfc2119>must</rfc2119> be a boolean.</para>

<para><error code="C0058">It is a <glossterm>dynamic error</glossterm>
if the <option>all</option> and <option>relative</option> options are
<emphasis>both</emphasis> <literal>true</literal>.</error></para>

<para>The <tag>p:add-xml-base</tag> step modifies its input as follows:</para>

<itemizedlist>
<listitem>
<para>For the document element: force the element to have an <tag class="attribute">xml:base</tag>
attribute with the document's [base URI] property's value as its value.</para>
</listitem>
<listitem>
<para>For other elements:</para>
<itemizedlist>
<listitem>
<para>If the <option>all</option> option has the value
<literal>true</literal>, force the element to have an <tag class="attribute">xml:base</tag> attribute with the element's [base
URI] value as its value.</para>
</listitem>
<listitem>
<para>If the element's [base URI] is different from the its parent's
[base URI], force the element to have an <tag class="attribute">xml:base</tag> attribute with the following
value: if the value of the <option>relative</option> option is
<literal>true</literal>, a string which, when resolved against the
parent's [base URI], will give the element's [base URI], otherwise the
element's [base URI].</para>
</listitem>
<listitem>
<para>Otherwise, if there is an <tag class="attribute">xml:base</tag> attribute present, remove it.
</para>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>

<section>
<title>Document properties</title>
<para feature="add-xml-base-preserves-all">All document properties are preserved.</para>
</section>
</section>
<section xml:id="c.cast-content-type">
<title>p:cast-content-type</title>

<para>The <tag>p:cast-content-type</tag> step changes the media type
of its input.</para>

<p:declare-step type="p:cast-content-type">
   <p:input port="source" content-types="*/*"/>
   <p:output port="result" content-types="*/*"/>
   <p:option name="content-type" as="xs:string"/>
</p:declare-step>

<para>The input document is transformed from one media type to another.
<error code="C0070">It is a <glossterm>dynamic
error</glossterm> if the supplied <option>content-type</option> is not
a valid media type of the form
“<literal><replaceable>type</replaceable>/<replaceable>subtype</replaceable>+<replaceable>ext</replaceable></literal>”.</error></para>

<itemizedlist>
<listitem>
<para>Casting from one XML media type to another simply changes the
“<literal>content-type</literal>” <glossterm baseform="document properties">document
property</glossterm>.
</para>
</listitem>
<listitem xml:id="c.data">
<para>Casting from a non-XML media type to an XML media type produces an
XML document with a <tag>c:data</tag> document element. The original
media type will be preserved in the
<tag class="attribute">content-type</tag> attribute on the
<tag>c:data</tag> element.</para>

<e:rng-pattern name="VocabData"/>

<para>The content of the <tag>c:data</tag> element is the base64 encoded
representation of the non-XML content.</para>
</listitem>
<listitem>
<para>Casting from an XML media type to a non-XML media type
<rfc2119>must</rfc2119> support the case where the input document is
a <tag>c:data</tag> document. The resulting document will
have the specified media type and a <glossterm>representation</glossterm> that
is the content of the <tag>c:data</tag> element after decoding the base64
encoded content.</para>
<para><error code="C0072">It is a <glossterm>dynamic
error</glossterm> if the <tag>c:data</tag> contains content is not
a valid base64 string.</error></para>
<para><error code="C0073">It is a <glossterm>dynamic
error</glossterm> if the <tag>c:data</tag> element does not have
a <tag class="attribute">content-type</tag> attribute.</error></para>
<para><error code="C0074">It is a <glossterm>dynamic
error</glossterm> if the <option>content-type</option> is supplied and is
not the same as the <tag class="attribute">content-type</tag> specified on
the <tag>c:data</tag> element.</error>
</para>
<para><impl>Casting from an XML media type to a non-XML media type when
the input document is not a <tag>c:data</tag> document is
<glossterm>implementation-defined</glossterm>.</impl></para>
</listitem>
<listitem>
<para><impl>What happens when one non-XML media type is cast to another
non-XML media type is <glossterm>implementation-defined</glossterm>.</impl>
<error code="C0071">It is a <glossterm>dynamic
error</glossterm> if the <tag>p:cast-content-type</tag> step
cannot perform the requested cast.</error></para>
</listitem>
</itemizedlist>

<para><error code="C075">In all cases except when the input document
is a <tag>c:data</tag> element, it is a <glossterm>dynamic
error</glossterm> if the <option>content-type</option> is not supplied.</error>
</para>

<section>
<title>Document properties</title>
<para feature="cast-content-type-preserves-some">All document
properties are preserved except the <code>content-type</code> property
which is updated accordingly.</para>
</section>
</section>
<section xml:id="c.compare">
<title>p:compare</title>

<para>The <code>p:compare</code> step compares two documents for
equality.</para>

<p:declare-step type="p:compare">
   <p:input port="source" primary="true" content-types="*/*"/>
   <p:input port="alternate" content-types="*/*"/>
   <p:output port="result" content-types="application/xml"/>
   <p:output port="differences" content-types="*/*" sequence="true"/>
   <p:option name="method" as="xs:QName"/>
   <p:option name="fail-if-not-equal" select="false()" as="xs:boolean"/>
   <p:option name="parameters" as="map(xs:QName,item())"/>
</p:declare-step>

<para>This step takes single documents on each of two ports and
compares them. If <option>method</option> is not specified, or if
<code>deep-equal</code> is specified, the comparison
uses <function>fn:deep-equal</function> (as defined in <biblioref linkend="xpath-functions"/>). <impl>Implementations of <tag>p:compare</tag>
<rfc2119>must</rfc2119> support the <code>deep-equal</code> <option>method</option>;
other supported methods are <glossterm>implementation-defined</glossterm>.</impl>
<error code="C0076">It is a <glossterm>dynamic error</glossterm> if
the comparison <option>method</option> specified in <tag>p:compare</tag>
is not supported by the implementation.</error>
<error code="C0077">It is a <glossterm>dynamic error</glossterm> if
the media types of the documents supplied are incompatible with the
comparison <option>method</option>.</error>
</para>

<para><error code="C0019">It is a <glossterm>dynamic error</glossterm>
if the documents are not equal according to the specified comparison
<option>method</option>, and the value of the
<option>fail-if-not-equal</option> option is
<literal>true</literal>.</error> If the documents are equal, or if the
value of the <option>fail-if-not-equal</option> option is
<literal>false</literal>, a <tag>c:result</tag> document is produced
with contents <literal>true</literal> if the documents are equal,
otherwise <literal>false</literal>.</para>

<para><impl>If
<option>fail-if-not-equal</option> is <code>false</code>, and the
documents differ, an <glossterm>implementation-defined</glossterm>
summary of the differences between the two documents may appear on the
<port>differences</port> port.</impl></para>

<section>
<title>Document properties</title>
<para feature="compare-preserves-none">No document properties are preserved.</para>
</section>
</section>
<section xml:id="c.count">
<title>p:count</title>

<para feature="p-count">The <code>p:count</code> step counts the number of documents in
the <code>source</code> input sequence and returns a single document
on <code>result</code> containing that number. The generated document
contains a single <tag>c:result</tag> element whose contents is the
string representation of the number of documents in the
sequence.</para>

<p:declare-step type="p:count">
   <p:input port="source" content-types="*/*" sequence="true"/>
   <p:output port="result" content-types="application/xml"/>
   <p:option name="limit" select="0" as="xs:integer"/>
</p:declare-step>

<para>If the <tag feature="p-count-limit" class="attribute">limit</tag> option is specified
and is greater than zero, the <tag>p:count</tag> step will count at most
that many documents. This provides a convenient mechanism to discover,
for example, if a sequence consists of more than 1 document, without
requiring every single document to be buffered before processing can
continue.</para>

<section>
<title>Document properties</title>
<para feature="count-preserves-none">No document properties are preserved.</para>
</section>
</section>
<section xml:id="c.delete">
<title>p:delete</title>

<para>The <code>p:delete</code> step deletes items specified by a match
pattern from the
<code>source</code> input document and produces the resulting document,
with the deleted items removed, on the <port>result</port> port.</para>

<p:declare-step type="p:delete">
   <p:input port="source" content-types="application/xml text/xml */*+xml"/>
   <p:output port="result" content-types="application/xml"/>
   <p:option name="match" required="true" as="xs:string" e:type="XSLTMatchPattern"/>
</p:declare-step>

<para>The value of the <option>match</option> option <rfc2119>must</rfc2119> be an
XSLTMatchPattern. A match pattern may match multiple items to be
deleted.</para>

<para>If an element is selected by the <option>match</option> option, the
entire subtree rooted at that element is deleted.</para>

<para>This step cannot be used to remove namespaces. <error code="C0062">It is a <glossterm>dynamic error</glossterm> if the
<option>match</option> option matches a namespace node.</error>
Also, note that deleting an attribute named
<tag class="attribute">xml:base</tag> does not change the base URI
of the element on which it occurred.</para>

<section>
<title>Document properties</title>
<para feature="delete-preserves-all">All document properties are preserved.</para>
</section>
</section>
<section xml:id="c.directory-list">
<title>p:directory-list</title>

<para>The <code>p:directory-list</code> step produces a list of the
contents of a specified
directory.</para>

<p:declare-step type="p:directory-list">
  <p:output port="result" content-type="application/xml"/>
  <p:option name="path" required="true" as="xs:anyURI"/>
  <p:option name="include-filter" as="xs:string" e:type="RegularExpression"/>
  <p:option name="exclude-filter" as="xs:string" e:type="RegularExpression"/>
</p:declare-step>

<para>The value of the <option>path</option> option
<rfc2119>must</rfc2119> be an <type>anyURI</type>. It is interpreted
as an IRI reference. If it is relative, it is made absolute against
the base URI of the element on which it is specified
(<tag>p:with-option</tag> or <tag>p:directory-list</tag> in the case of a
<olink targetdoc="../xproc20/xproc20.xml" targetptr="option-shortcut">syntactic shortcut</olink> value).</para>

<para><error code="C0017">It is a
<glossterm>dynamic error</glossterm> if the absolute path does not
identify a directory.</error> <error code="C0012">It is a
<glossterm>dynamic error</glossterm> if the contents of the directory
path are not available to the step due to access restrictions in the
environment in which the pipeline is run.</error></para>

<para><impl>Conformant processors <rfc2119>must</rfc2119> support directory paths whose
scheme is <code>file</code>. It is
<glossterm>implementation-defined</glossterm> what other schemes are
supported by <tag>p:directory-list</tag>, and what the interpretation
of 'directory', 'file' and 'contents' is for those schemes.</impl>
</para>

<para>If present, the value of the <option>include-filter</option>
or <option>exclude-filter</option>
option <rfc2119>must</rfc2119> be a regular expression as specified in <biblioref linkend="xpath-functions"/>, section 7.61 “<literal>Regular Expression
Syntax</literal>”.</para>

<para>If the <option>include-filter</option> pattern matches a
directory entry's name, the entry is included in the output. If the
<option>exclude-filter</option> pattern matches a directory entry's name,
the entry is excluded in the output. If both options are provided, the
include filter is processed first, then the exclude filter.</para>

<para xml:id="cv.directory">The result document produced for
the specified directory path has a <tag>c:directory</tag> document
element whose base URI is the directory path and whose
<tag class="attribute">name</tag> attribute is the last segment
of the directory path (that is, the directory's (local) name).</para>

<e:rng-pattern name="VocabDirectory"/>

<para>Its contents are determined as follows, based on the entries in
the directory identified by the directory path. For each entry in the
directory, if either no <option>filter</option> was specified, or the
(local) name of the entry matches the filter pattern, a
<tag>c:file</tag>, a <tag>c:directory</tag>, or a <tag>c:other</tag>
element is produced, as follows:
</para>

<itemizedlist>
<listitem>
<para>A <tag>c:directory</tag> is produced for each subdirectory not
determined to be special.</para>
</listitem>
<listitem>
<para xml:id="cv.file">A <tag>c:file</tag> is produced for each file
not determined to be special.</para>
<e:rng-pattern name="VocabFile"/>
</listitem>
<listitem>
<para xml:id="cv.other"><impl>Any file or directory determined to be
special by the <tag>p:directory-list</tag> step may be output using a
<tag>c:other</tag> element but the criteria for marking a file as
special are <glossterm>implementation-defined</glossterm>.</impl>
</para>
<e:rng-pattern name="VocabOther"/>
</listitem>
</itemizedlist>

<para>When a directory entry is a subdirectory, that directory's entries are not
output as part of that entry's <tag>c:directory</tag>.  A user must apply this step
again to the subdirectory to list subdirectory contents.</para>

<para>Each of the elements <tag>c:file</tag>, <tag>c:directory</tag>,
and <tag>c:other</tag> has a <code>name</code> attribute when it
appears within the top-level <tag>c:directory</tag> element, whose
value is a relative IRI reference, giving the (local) file or
directory name.</para>

<para><impl>Any attributes other than <tag class="attribute">name</tag> on
<tag>c:file</tag>, <tag>c:directory</tag>, or <tag>c:other</tag>
are <glossterm>implementation-defined</glossterm>.</impl></para>

<section>
<title>Document properties</title>
<para feature="directory-list-preserves-none">No document properties are preserved.</para>
</section>
</section>
<section xml:id="c.error">
<title>p:error</title>

<para>The <code>p:error</code> step generates a <glossterm role="unwrapped">dynamic error</glossterm> using the input provided
to the step.</para>

<p:declare-step type="p:error">
  <p:input port="source" sequence="true" content-types="*/*"/>
  <p:output port="result" sequence="true" content-types="*/*"/>
  <p:option name="code" required="true" as="xs:QName"/>
  <p:option name="code-prefix" as="xs:NCName"/>
  <p:option name="code-namespace" as="xs:anyURI"/>
</p:declare-step>

<para>The value of the <option>code</option> option
<rfc2119>must</rfc2119> be a <type>QName</type>.
If the lexical value does not contain a colon, then the <tag class="attribute">code-namespace</tag> may be used to specify the
namespace of the code. In that case, the <tag class="attribute">code-prefix</tag> may be specified to suggest a
prefix for the code. <error code="D0034">It is a
<glossterm>dynamic error</glossterm> to specify a new namespace or
prefix if the lexical value of the specified name contains a
colon.</error></para>

<para>This step uses the document provided on its input as the content
of the error raised. An instance of the
<tag>c:errors</tag> element will be produced on the error output port, as is
always the case for <glossterm baseform="dynamic error" role="unwrapped">dynamic errors</glossterm>.
The error generated can be caught by a <tag>p:try</tag> just like any
other dynamic error.</para>

<para>For authoring convenience, the <tag>p:error</tag> step is
declared with a single, primary output port. With respect to
<glossterm baseform="connection">connections</glossterm>, this port behaves like
any other output port even though nothing can ever
appear on it since the step always fails.</para>

<para>For example, given the following invocation:</para>
<programlisting language="xml">&lt;p:error xmlns:my="http://www.example.org/error"
         name="bad-document" code="my:unk12"&gt;
   &lt;p:input port="source"&gt;
     &lt;p:inline&gt;
       &lt;message&gt;The document element is unknown.&lt;/message&gt;
     &lt;/p:inline&gt;
   &lt;/p:input&gt;
&lt;/p:error&gt;</programlisting>

<para>The error vocabulary element (and document) generated on the
error output port would be:</para>
<programlisting language="xml">&lt;c:errors xmlns:c="http://www.w3.org/ns/xproc-step"
          xmlns:p="http://www.w3.org/ns/xproc"
          xmlns:my="http://www.example.org/error"&gt;
 &lt;c:error name="bad-document" type="p:error"
          code="my:unk12"&gt;&lt;message&gt;The document element is unknown.&lt;/message&gt;
&lt;/c:error&gt;
&lt;/c:errors&gt;</programlisting>

<para>The <tag class="attribute">href</tag>,
<tag class="attribute">line</tag> and <tag class="attribute">column</tag>,
or <tag class="attribute">offset</tag>, might also be present on the
<tag>c:error</tag> to identify the location of the <tag>p:error</tag>
element in the pipeline.</para>

<section>
<title>Document properties</title>
<para feature="error-preserves-none">No document properties are preserved.</para>
</section>
</section>
<section xml:id="c.escape-markup">
<title>p:escape-markup</title>

<para>The <code>p:escape-markup</code> step applies XML serialization to the
children of the document element and replaces those children with their
serialization. The outcome is a single element with text content that
represents the "escaped" syntax of the children as they were
serialized.</para>

<p:declare-step type="p:escape-markup">
  <p:input port="source" content-types="application/xml text/xml */*+xml"/>
  <p:output port="result" content-types="application/xml"/>
  <p:option name="serialization" as="map(xs:string,xs:anyAtomicValue)"/>
</p:declare-step>

<para>This step supports the standard serialization options as
specified in <link linkend="xml-serialization"/>. These options
control how the output markup is produced before it is escaped.
</para>

<para>For example, the input:</para>
<programlisting language="xml">&lt;description&gt;
&lt;div xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;p&gt;This is a chunk of XHTML.&lt;/p&gt;
&lt;/div&gt;
&lt;/description&gt;</programlisting>
<para>produces:</para>
<programlisting language="xml">&lt;description&gt;
&amp;lt;div xmlns="http://www.w3.org/1999/xhtml"&amp;gt;
&amp;lt;p&gt;This is a chunk of XHTML.&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/description&gt;</programlisting>

<note xml:id="note-escaped">
<para>The result of this step is an XML document that contains the
Unicode characters that are the characters that result from escaping
the input. It is not encoded characters in a serialized octet stream,
therefore, the serialization options related to encoding characters
(<option>byte-order-mark</option>, <option>encoding</option>, and
<option>normalization-form</option>) do not apply. They are omitted
from the standard serialization options on this step.</para>
</note>

<para>By default, this step <rfc2119>must not</rfc2119> generate an
XML declaration in the escaped result.</para>

<section>
<title>Document properties</title>
<para feature="escape-markup-preserves-none">No document properties are preserved.</para>
</section>
</section>
<section xml:id="c.filter">
<title>p:filter</title>

<para>The <code>p:filter</code> step selects portions of the source document
based on a (possibly dynamically constructed) XPath select expression.</para>

<p:declare-step type="p:filter">
  <p:input port="source" content-types="application/xml text/xml */*+xml"/>
  <p:output port="result" sequence="true" content-types="application/xml"/>
  <p:option name="select" required="true" as="xs:string" e:type="XPathExpression"/>
</p:declare-step>

<para>This step behaves just like an <tag>p:input</tag> with
a <tag class="attribute">select</tag> expression except that the select
expression is computed dynamically.</para>

<section>
<title>Document properties</title>
<para feature="filter-preserves-all">All document properties are preserved.</para>
</section>
</section>
<section xml:id="c.http-request">
<title>p:http-request</title>

<para>The <code>p:http-request</code> step provides for interaction
with resources over HTTP or related protocols.
The input
document provided on the <port>source</port> port specifies a request
by a single <tag>c:request</tag> element. This element specifies
the method, resource, and other request properties as well as possibly
including an entity body (content) for the request.</para>

<p:declare-step type="p:http-request">
  <p:input port="source" content-types="*/*"/>
  <p:output port="result" sequence="true" content-types="*/*"/>
  <p:option name="serialization" as="map(xs:string,xs:anyAtomicValue)"/>
</p:declare-step>

<para>The <option>serialization</option> option is provided to control the
serialization of any content which is sent as part of the request.
The effect of these options is as specified in
<link linkend="serialization">Serialization</link>.
See <link linkend="c.request_body"/> for a discussion of when serialization
occurs in constructing a request.</para>

<para><error code="C0040">It is a <glossterm>dynamic error</glossterm>
if the document element of the document that arrives on the
<port>source</port> port is not <tag>c:request</tag>.</error></para>

<note xml:id="ednote-json" role="editorial">
<title>Editorial Note</title>
<para>Can the input document be JSON?</para>
</note>

<section xml:id="cv.request">
<title>Specifying a request</title>

<para>An HTTP request is represented by a <tag>c:request</tag> element.</para>

<e:rng-pattern name="VocabHttpRequest"/>

<para><error code="C0006">It is a <glossterm>dynamic error</glossterm> if the
<tag class="attribute">method</tag> is not specified on a <tag>c:request</tag>.
</error>
<error code="C0005">It is a <glossterm>dynamic error</glossterm> if the
request contains a <tag>c:body</tag> or <tag>c:multipart</tag> but the
<tag class="attribute">method</tag> does not allow for an entity body being sent with the request.</error></para>

<para><error code="C0004">It is a <glossterm>dynamic error</glossterm> if the
<code>status-only</code> attribute has the value <literal>true</literal> and
the <code>detailed</code> attribute does not have the value <literal>true</literal>.</error></para>

<para>The <code>method</code> attribute specifies the method to be
used against the IRI specified by the <code>href</code> attribute,
e.g. <code>GET</code> or <code>POST</code> (the value is not case-sensitive).
If the <code>href</code>
attribute is not absolute, it will be resolved against the base URI of
the element on which it is occurs.</para>

<note xml:id="note-http-get">
<para>In the case of simple “GET” requests, implementors are encouraged
to support as many protocols as practical. In particular, pipeline authors may
attempt to use <tag>p:http-request</tag> to load documents with computed
URIs using the <literal>file:</literal> scheme.</para></note>

<para>If the <code>username</code> attribute is specified, the
<code>username</code>, <code>password</code>,
<code>auth-method</code>, and <code>send-authorization</code>
attributes are used to handle authentication according to the selected
authentication method.</para>

<para>For the purposes of avoiding an authentication challenge, if the
<code>send-authorization</code> attribute has the value
<literal>true</literal> and the authentication method specified by the
<code>auth-method</code> supports generation of an
<code>Authorization</code> header without a challenge, then an
<code>Authorization</code> header is generated and sent on the first
request. If the <code>send-authorization</code> attribute is absent or
has the value
<literal>false</literal>, then the first request is sent without an
<code>Authorization</code> header.</para>

<para>If the initial response to the request is an
authentication challenge, the <code>auth-method</code>,
<code>username</code>, <code>password</code> and any relevant data from
the challenge are used to generate an
<code>Authorization</code> header and the request is sent again. If
that authorization fails, the request is not retried.</para>

<para>Appropriate values for the <code>auth-method</code> attribute
are “Basic” or “Digest” but other values are allowed.
If the authentication method is “Basic” or “Digest”, authentication
is handled as per <biblioref linkend="rfc2617"/>.
<impl>The
interpretation of <code>auth-method</code> values on
<tag>c:request</tag> other than “Basic” or “Digest” is
<glossterm>implementation-defined</glossterm>.</impl></para>

<para><error code="C0003">It
is a <glossterm>dynamic error</glossterm> if a <option>username</option>
or <option>password</option> is specified without specifying an
<option>auth-method</option>, if
the requested
<option>auth-method</option> isn't supported, or the authentication
challenge contains an authentication method that isn't
supported.</error> All implementations are required to support "Basic"
and "Digest" authentication per <biblioref linkend="rfc2617"/>.</para>

  <para>The <code>c:header</code> element specifies a
header name and value, either for inclusion in a request, or as received in a response.</para>

<e:rng-pattern name="VocabHeader" xml:id="cv.header"/>

<para>The request is formulated from the attribute values on the
<tag>c:request</tag> element and its
<tag>c:header</tag> and <tag>c:multipart</tag> or <tag>c:body</tag> children,
if present, and transmitted to the host (and port, if present) specified by the
<code>href</code> attribute.  The details of how the request entity body, if any, is
constructed are given in <xref linkend="c.response_body"/>.</para>

<para>When the request is formulated, the step and/or protocol
implementation may add headers as necessary to either complete the
request or as appropriate for the content specified (e.g. transfer
encodings). A user of this step is guaranteed that their requested
headers and content will be sent with the exception of any conflicts
with protocol-related headers.</para>

<para>The <tag>p:http-request</tag> step allows users to specify
independently values that are not always independent. For example,
some combinations of <tag>c:header</tag> values
(e.g., <literal>Content-Type</literal>)
may be inconsistent
with values that the step and/or protocol implementation must set. In
a few cases, the step provides more than one mechanism to specify what
is actually a single value (e.g., the boundary string in multipart
messages).
<error code="C0020">It is a
<glossterm>dynamic error</glossterm> if the the user specifies a value
or values that are inconsistent with each other or with the requirements
of the step or protocol.</error>
</para>
</section>

<section xml:id="file-globbing">
<title>Filename globbing</title>

<para>Implementations that support <literal>file:</literal> URIs,
<rfc2119>should</rfc2119> support “globbing”. For example, the
URI <uri>file:///path/to/dir/*.xml</uri> should return all of the
XML documents in the directory
<filename class="directory">/path/to/dir</filename>.</para>

<note xml:id="ednote-globbing" role="editorial">
<para>Must define the globbing rules!</para>
</note>
</section>

<section xml:id="c.request_body">
<title>Request Entity body conversion</title>

<para>The <code>c:multipart</code> element specifies a multi-part
body, per <biblioref linkend="rfc1521"/>, either for inclusion in a
request or as received in a response.</para>

<e:rng-pattern name="VocabMultipart" xml:id="cv.multipart"/>

<para>In the context of a request, the media type of the
<tag>c:multipart</tag> <rfc2119>must</rfc2119> be a multipart media
type (i.e. have a main type of 'multipart'). If the
<code>content-type</code> attribute is not specified, a value of
“<literal>multipart/mixed</literal>” will be assumed. (<impl>Whether
or not, and to what extent, “<literal>multipart/byte-ranges</literal>”
responses are supported is
<glossterm>implementation-defined</glossterm>.)</impl>
</para>

<para>The <code>boundary</code> attribute is required and is used to
provide a multipart boundary marker. The implementation must use this
boundary marker and must prefix the value with the string
“<literal>--</literal>” when formulating the multipart message. <error code="C0002">It is a <glossterm>dynamic error</glossterm> if the value
starts with the string “<literal>--</literal>”.</error></para>

<para>If the boundary is also specified as a parameter in the
<option>content-type</option> option, then the parameter value specified
and the <option>boundary</option> value specified <rfc2119>must</rfc2119>
be the same. If the boundary is specified in both the <option>boundary</option>
option and the <option>content-type</option> option then the two values
<rfc2119>must</rfc2119> be the same.</para>

<para>The <tag>c:body</tag> element holds the body or body part of the message.  Each of the attributes holds controls some aspect of the encoding the request body or decoding the body element's content when the request is formulated.  These are specified as follows:</para>

<e:rng-pattern name="VocabBody" xml:id="cv.body"/>

<para>The <code>content-type</code> attribute specifies the media type
of the body or body part, that is, the value of its
<code>Content-Type</code> header. If the media type is not an XML type
or text, the content must already be base64-encoded.</para>

<para>The <code>encoding</code> attribute controls the decoding of the
element content for formulating the body. A value of
<literal>base64</literal> indicates the element's content is a base64
encoded string whose byte stream should be sent as the message body.
<impl>An implementation may support encodings other than
<literal>base64</literal> but these encodings and their names are
<glossterm>implementation-defined</glossterm>.</impl>
<error code="C0052">It is a <glossterm>dynamic
error</glossterm> if the encoding specified is not supported by the
implementation.</error></para>

<note xml:id="note-single-set-ser">
<para>The <tag>p:http-request</tag> step provides only a single set of
serialization options for XML media types. There's no direct support
for sending a multipart message with two XML parts encoded
differently.</para>
</note>

<para>For each body or body part, the <code>id</code> attribute
specifies the value of the <code>Content-ID</code> header;
the <code>description</code> attribute specifies the
value of the <code>Content-Description</code> header;
and the <code>disposition</code> attribute specifies the value
of the <code>Content-Disposition</code> header.
</para>

<para>If an entity body is to be sent as part of a request (e.g. a
<code>POST</code>), either a <tag>c:body</tag> element, specifying the
request entity body, or a <tag>c:multipart</tag> element, specifying
multiple entity body parts, may be used. When <tag>c:multipart</tag>
is used it may contain multiple <tag>c:body</tag> children. A
<tag>c:body</tag> specifies the construction of a body or body part as
follows:</para>

<para>If the <code>content-type</code> attribute does not specify an
XML media type, or the <code>encoding</code> attribute is
“<literal>base64</literal>”, then <error code="C0028">it is a
<glossterm>dynamic error</glossterm> if the content of the
<tag>c:body</tag> element does not consist entirely of
characters</error>, and the entity body or body part will consist of
exactly those characters.</para>

<para>Otherwise (the <code>content-type</code> attribute
<emphasis>does</emphasis> specify an XML media type and the
<code>encoding</code> attribute is <emphasis>not</emphasis> 'base64'),
<error code="C0022">it is a <glossterm>dynamic error</glossterm> if
the content of the <tag>c:body</tag> element does not consist of
exactly one element, optionally preceded and/or followed by any number
of processing instructions, comments or whitespace characters</error>,
and the entity body or body part will consist of the serialization of
a document node containing that content. The serialization of that
document is controlled by the serialization options on the
<code>p:http-request</code> step itself.</para>

<para>For example, the following input to a
<code>p:http-request</code> step will POST a small XML
document:</para>

<programlisting language="xml">&lt;c:request method="POST" href="http://example.com/someservice"&gt;
&lt;c:body xmlns:c="http://www.w3.org/ns/xproc-step" content-type="application/xml"&gt;
&lt;doc&gt;
&lt;title&gt;My document&lt;/title&gt;
&lt;/doc&gt;
&lt;/c:body&gt;
&lt;/c:request&gt;
</programlisting>
  <para>The corresponding request should look something like this:</para>

  <programlisting language="xml">POST http://example.com/someservice HTTP/1.1
Host: example.com
Content-Type: application/xml; charset="utf-8"

&lt;?xml version='1.0'?&gt;
&lt;doc&gt;
&lt;title&gt;My document&lt;/title&gt;
&lt;/doc&gt;
</programlisting>
</section>

<section xml:id="c.request_response">
<title>Managing the response</title>

<note xml:id="ednote-content-types" role="editorial">
<para>Where do we say that for URI schemes (such as
<code>file:</code> and <code>ftp:</code>) where a content type is not
provided by the underlying request, the content type is
implementation-dependent?</para>
</note>

<para>The handling of the response to the request and the generation
of the step's result document is controlled by the
<code>status-only</code>, <code>override-content-type</code> and
<code>detailed</code> attributes on the <tag>c:request</tag>
input.</para>

<para>The <code>override-content-type</code> attribute controls
interpretation of the response's <code>Content-Type</code> header. If
this attribute is present, the response will be treated as if it
returned the <code>Content-Type</code> given by its value. This
original <code>Content-Type</code> header will however be reflected
unchanged as a <tag>c:header</tag> in the result document. <error code="C0030">It is a <glossterm>dynamic error</glossterm> if the
<code>override-content-type</code> value cannot be used (e.g.
<code>text/plain</code> to override
<code>image/png</code>).</error></para>

<para>If the <code>override-content-type</code> includes an encoding
parameter, then that encoding <rfc2119>must</rfc2119> be used to
read the document.</para>

<para>If the <code>status-only</code> attribute has the value
<literal>true</literal>, the result document will contain only header
information. The entity of the response will not be processed to
produce a <tag>c:body</tag> or <tag>c:multipart</tag> element.</para>

<para>The <tag>c:response</tag> element represents an HTTP response.
The response's status code is encoded in the <code>status</code>
attribute and the headers and entity body are processing into
<tag>c:header</tag> and <tag>c:multipart</tag> or <tag>c:body</tag>
content.</para>

<e:rng-pattern name="VocabHttpResponse" xml:id="c.response"/>

<para>The value of the <code>detailed</code> attribute determines the
content of the result document. If it is <literal>true</literal>, the
response to the request is handled as follows:</para>

<orderedlist>
<listitem><para>A single <tag>c:response</tag> element is produced with the <code>status</code> attribute containing the status of the response received.</para></listitem>
<listitem><para>Each response header is translated into a <tag>c:header</tag> element.</para></listitem>
<listitem><para>Unless the <code>status-only</code> attribute has a value
<literal>true</literal>, the entity body of the response is converted into
a <tag>c:body</tag> or <tag>c:multipart</tag> element via the rules given in
 <xref linkend="c.response_body"/>.</para></listitem>
</orderedlist>

<para>Otherwise (the <code>detailed</code> attribute is not specified
or its value is <literal>false</literal>), the response to the request
is handled as follows:</para>

<orderedlist>
<listitem><para>If the media type (as determined by the
<code>override-content-type</code> attribute or the
<code>Content-Type</code> response header) is an XML media type, the
entity is decoded if necessary, then parsed as an XML document:</para>

<itemizedlist>
<listitem>
<para>The parser which <tag>p:http-request</tag> employs
<rfc2119>must</rfc2119> process the external subset; all general and
external parsed entities <rfc2119>must</rfc2119> be fully expanded.</para>

<note xml:id="ednote-parser" role="editorial">
<title>Editorial Note</title>
<para>The requirement to process the external subset comes from p:load,
we probably don't want to impose that on all p:http-request calls.
Need a way to control it?</para>
</note>

</listitem>
<listitem>
<para>It
<rfc2119>may</rfc2119> perform <tag class="attribute">xml:id</tag>
processing, but it <rfc2119>must not</rfc2119> perform any other
processing, such as expanding XIncludes.</para>
</listitem>
<listitem>
<para>The parser
<rfc2119>must</rfc2119> be conformant to <citetitle>Namespaces in
XML</citetitle>.</para>
</listitem>
<listitem>
<para>Parsing the document
<rfc2119>must not</rfc2119> fail due to validation errors.
</para>
</listitem>
</itemizedlist>

<para>The resulting XML document is
produced on the <code>result</code> output port as the entire output
of the step.</para>

</listitem>
<listitem><para>Otherwise, the entity body of the response is converted into
a <tag>c:body</tag> or <tag>c:multipart</tag> element via the rules given in
<xref linkend="c.response_body"/>.</para></listitem>
</orderedlist>

<para>In either case the base URI of the output document is the resolved value
of the <code>href</code> attribute from the input <tag>c:request</tag>.</para>

<section xml:id="redirects">
<title>Redirects</title>

<para>One possible response from an HTTP request is a redirect,
indicated by a status code in the three-hundred range. The precise
semantics of the 3xx return codes are laid out by section
<citetitle>10.3 Redirection 3xx</citetitle> in <biblioref linkend="rfc2616"/>.
</para>

<para>The <tag>p:http-request</tag> step <rfc2119>should</rfc2119> follow
redirect requests (in a manner consistent with <biblioref linkend="rfc2616"/>)
if they are returned by the server.
</para>
</section>

<section xml:id="cookies">
<title>Cookies</title>

<para>With one exception, in version 1.0 of XProc, the
<tag>p:http-request</tag> step does not provide any standard
mechanisms for managing cookies. <impl>Pipeline authors that need to
preserve cookies across several <tag>p:http-request</tag> calls in the
same pipeline or across multiple invocations of the same or different
pipelines will have to rely on
<glossterm>implementation-defined</glossterm> mechanisms.</impl>
</para>

<para>The exception arises in the case of redirection. If a redirect
response includes cookies, those cookies <rfc2119>should</rfc2119> be
forwarded as appropriate to the redirected location when the
redirection is followed.</para>

<para>This behavior will allow the <tag>p:http-request</tag> step to
interoperate with web services that use cookies as part of an
authentication protocol.</para>

</section>
 </section>

<section xml:id="c.response_body">
<title>Converting Response Entity Bodies</title>

<para>The entity of a response may be multipart per <biblioref linkend="rfc1521"/>. In those situations, the result document will be
a <tag>c:multipart</tag> element that contains multiple
<tag>c:body</tag> elements inside.</para>

<note xml:id="note-multipart-multipart">
<para>Although it is technically possible for any of the individual
parts of a multipart message to <emphasis>also</emphasis> be
multipart, XProc does not provide a standard representation for such
messages. <impl>The interpretation of a multipart message inside
another multipart message is
<glossterm>implementation-dependent</glossterm>.</impl></para>
</note>

<para>The result of the <tag>p:http-request</tag> step is an XML
document. For media types (images, binaries, etc.) that can't be
represented as a sequence of Unicode characters, the response is
encoded as <literal>base64</literal>
and then returned as text children of the <tag>c:body</tag> element.
If the content is base64-encoded, the <tag class="attribute">encoding</tag> attribute on <tag>c:body</tag> must
be set to “<literal>base64</literal>”.</para>

<note xml:id="ednote-non-xml" role="editorial">
<title>Editorial Note</title>
<para>This section hasn't been updated to reflect the fact that
non-XML documents are now possible. It should probably say
something like:</para>
<para>If the document identified has a non-XML content type, no extra
processing is mandated. The number and variety of media types
that an implementation can load is
implementation-defined.</para>
</note>

<para>If the media type of the response
is a text type with a
<code>charset</code> parameter that is a Unicode character encoding
(per <biblioref linkend="unicodetr17"/>) or
is recognized as a non-XML media type whose contents are encoded as a
sequence of Unicode characters (e.g. it has a character parameter or
the definition of the media type is such that it requires Unicode),
the content of the constructed <tag>c:body</tag> element is the translation
of the text into a sequence of Unicode characters.</para>

<para>If the response is an XML media type, the content of the
constructed <tag>c:body</tag> element is the result of decoding the
body as necessary, then parsing it with an XML parser.</para>

<itemizedlist>
<listitem>
<para>The parser which <tag>p:http-request</tag> employs
<rfc2119>must</rfc2119> process the external subset; all general and
external parsed entities <rfc2119>must</rfc2119> be fully expanded.</para>

<note xml:id="ednote-parser" role="editorial">
<title>Editorial Note</title>
<para>The requirement to process the external subset comes from p:load,
we probably don't want to impose that on all p:http-request calls.
Need a way to control it?</para>
</note>

</listitem>
<listitem>
<para>It
<rfc2119>may</rfc2119> perform <tag class="attribute">xml:id</tag>
processing, but it <rfc2119>must not</rfc2119> perform any other
processing, such as expanding XIncludes.</para>
</listitem>
<listitem>
<para>The parser
<rfc2119>must</rfc2119> be conformant to <citetitle>Namespaces in
XML</citetitle>.</para>
</listitem>
<listitem>
<para>Parsing the document
<rfc2119>must not</rfc2119> fail due to validation errors.
</para>
</listitem>
</itemizedlist>

<para>If the content
is not well-formed, the step fails.</para>

<note xml:id="ednote-combine-parsing" role="editorial">
<title>Editorial Note</title>
<para>This prose should be consolidated into a single place.</para>
</note>

<para>In a <tag>c:body</tag> in a response, the
<tag class="attribute">content-type</tag> attribute <rfc2119>must</rfc2119>
be an exact copy of the value returned in the
<literal>Content-Type</literal> header. That is, it must reflect the
content type actually returned, not any override value that may have been
specified, and it must include any parameters returned by the server.</para>

<para>In the case of a multipart response, the same rules apply when
constructing a <tag>c:body</tag> element for each body part
encountered.</para>

<note xml:id="note-text-html">
<para>Given the above description, any content identified as
<code>text/html</code> will be encoded as (escaped) text or
base64-encoded in the <tag>c:body</tag> element, as HTML isn't always
well-formed XML. A user can attempt to convert such content into XML
using the <tag>p:unescape-markup</tag> step.</para>
</note>
</section>

<section xml:id="example-http-request">
<title>HTTP Request Example</title>

<para>A simple form might be posted as follows:</para>
<programlisting language="xml">&lt;c:request method="POST" href="http://www.example.com/form-action" xmlns:c="http://www.w3.org/ns/xproc-step"&gt;
&lt;c:body content-type="application/x-www-form-urlencoded"&gt;
name=W3C&amp;amp;spec=XProc
&lt;/c:body&gt;
&lt;/c:request&gt;</programlisting>
<para>and if the response was an XHTML document, the result document would be:</para>
<programlisting language="xml">&lt;c:response status="200" xmlns:c="http://www.w3.org/ns/xproc-step"&gt;
&lt;c:header name="Date" value=" Wed, 09 May 2007 23:12:24 GMT"/&gt;
&lt;c:header name="Server" value="Apache/1.3.37 (Unix) PHP/4.4.5"/&gt;
&lt;c:header name="Vary" value="negotiate,accept"/&gt;
&lt;c:header name="TCN" value="choice"/&gt;
&lt;c:header name="P3P" value="policyref='http://www.w3.org/2001/05/P3P/p3p.xml'"/&gt;
&lt;c:header name="Cache-Control" value="max-age=600"/&gt;
&lt;c:header name="Expires" value="Wed, 09 May 2007 23:22:24 GMT"/&gt;
&lt;c:header name="Last-Modified" value="Tue, 08 May 2007 16:10:49 GMT"/&gt;
&lt;c:header name="ETag" value="'4640a109;42380ddc'"/&gt;
&lt;c:header name="Accept-Ranges" value="bytes"/&gt;
&lt;c:header name="Keep-Alive" value="timeout=2, max=100"/&gt;
&lt;c:header name="Connection" value="Keep-Alive"/&gt;
&lt;c:body content-type="application/xhtml+xml"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;head&gt;&lt;title&gt;OK&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;&lt;p&gt;OK!&lt;/p&gt;&lt;/body&gt;
&lt;/html&gt;
&lt;/c:body&gt;
&lt;/c:response&gt;</programlisting>
</section>

<section>
<title>Document properties</title>
<para feature="http-request-preserves-none">No document properties are preserved.</para>
</section>
</section>
<section xml:id="c.identity">
<title>p:identity</title>

<para>The <code>p:identity</code> step makes a verbatim copy of its input
available on its output.</para>

<p:declare-step type="p:identity">
  <p:input port="source" content-types="*/*" sequence="true"/>
  <p:output port="result" sequence="true" content-types="*/*"/>
</p:declare-step>

<para>If the implementation supports passing PSVI annotations between
steps, the <tag>p:identity</tag> step <rfc2119>must</rfc2119> preserve
any annotations that appear in the input.</para>

<section>
<title>Document properties</title>
<para feature="identity-preserves-all">All document properties are preserved.</para>
</section>
</section>
<section xml:id="c.insert">
<title>p:insert</title>

<para>The <code>p:insert</code> step inserts the
<code>insertion</code> port's document into the <port>source</port>
port's document relative to the matching elements in the
<code>source</code> port's document.</para>

<p:declare-step type="p:insert">
   <p:input port="source" primary="true" content-types="application/xml text/xml */*+xml"/>
   <p:input port="insertion" sequence="true" content-types="application/xml text/xml */*+xml"/>
   <p:output port="result" content-types="application/xml"/>
   <p:option name="match" select="'/*'" as="xs:string" e:type="XSLTMatchPattern"/>
   <p:option name="position" required="true" as="xs:token" e:type="first-child|last-child|before|after"/>
</p:declare-step>

<para>The value of the <option>match</option> option
<rfc2119>must</rfc2119> be an XSLTMatchPattern. <error code="C0023">It
is a <glossterm>dynamic error</glossterm> if that pattern matches
anything other than element, text, processing-instruction, or comment nodes.</error>
Multiple matches are
allowed, in which case multiple copies of the <port>insertion</port>
documents will occur. If no elements match, then the document is
unchanged.</para>

<para>The value of the <option>position</option> option <rfc2119>must</rfc2119> be an NMTOKEN in
the following list:
</para>

<itemizedlist>
<listitem>
<para>“<literal>first-child</literal>” - the insertion is made as the first child of the match;</para>
</listitem>
<listitem>
<para>“<literal>last-child</literal>” - the insertion is made as the last child of the match;</para>
</listitem>
<listitem>
<para>“<literal>before</literal>” - the insertion is made as the immediate preceding sibling of the match;</para>
</listitem>
<listitem>
<para>“<literal>after</literal>” - the insertion is made as the immediate following sibling of the match.</para>
</listitem>
</itemizedlist>

<para><error code="C0025">It is a <glossterm>dynamic error</glossterm>
if the match pattern matches anything other than an element node and
the value of the <option>position</option> option is
“<literal>first-child</literal>” or
“<literal>last-child</literal>”.</error></para>

<para>As the inserted elements are part of the output of the step they
are not considered in determining matching elements. If an empty sequence
appears on the <port>insertion</port> port, the result will be the same
as the source.</para>

<section>
<title>Document properties</title>
<para feature="insert-preserves-all">All document properties on the
<port>source</port> port are preserved. No document properties on the
<port>insertion</port> port are preserved.</para>
</section>
</section>
<section xml:id="c.label-elements">
<title>p:label-elements</title>

<para>The <code>p:label-elements</code> step generates a label for each matched
element and stores that label in the specified attribute.</para>

<p:declare-step type="p:label-elements">
  <p:input port="source" content-types="application/xml text/xml */*+xml"/>
  <p:output port="result" content-types="application/xml"/>
  <p:option name="attribute" select="'xml:id'" as="xs:QName"/>
  <p:option name="attribute-prefix" as="xs:NCName"/>
  <p:option name="attribute-namespace" as="xs:anyURI"/>
  <p:option name="label" select="'concat(&#34;_&#34;,$p:index)'" as="xs:string" e:type="XPathExpression"/>
  <p:option name="match" select="'*'" as="xs:string" e:type="XSLTMatchPattern"/>
  <p:option name="replace" select="'true'" as="xs:boolean"/>
</p:declare-step>

<para>The value of the <option>attribute</option> option
<rfc2119>must</rfc2119> be a <type>QName</type>.
If the lexical value does not contain a colon, then the <tag class="attribute">attribute-namespace</tag> may be used to specify the
namespace of the attribute name. In that case, the <tag class="attribute">attribute-prefix</tag> may be specified to suggest a
prefix for the attribute name. <error code="D0034">It is a
<glossterm>dynamic error</glossterm> to specify a new namespace or
prefix if the lexical value of the specified name contains a
colon.</error>
</para>

<para>The value of the <option>label</option> option is an XPath
expression used to generate the value of the attribute label.</para>

<para>The value of the <option>match</option> option
<rfc2119>must</rfc2119> be an XSLTMatchPattern. <error code="C0023">It
is a <glossterm>dynamic error</glossterm> if that expression matches
anything other than element nodes.</error></para>

<para>The value of the <option>replace</option>
<rfc2119>must</rfc2119> be a boolean value and is used to indicate
whether existing attribute values are replaced.</para>

<para>This step operates by generating attribute labels for each
element matched. For every matched element, the expression is
evaluated with the context node set to the matched element. An
attribute is added to the matched element using the attribute name is
specified the <option>attribute</option> option and the string value
of result of evaluating the expression. If the attribute already
exists on the matched element, the value is replaced with the string
value only if the <option>replace</option> option has the value of
<literal>true</literal>.</para>

<para>If this step is used to add or change the value
of an attribute named “<literal>xml:base</literal>”, the base URI
of the element <rfc2119>must</rfc2119> also be amended accordingly.</para>

<para>An implementation must bind the variable
“<literal>p:index</literal>” in the static context of each evaluation
of the XPath expression to the position of the element in the sequence
of matched elements. In other words, the first element (in document
order) matched gets the value “<literal>1</literal>”, the second gets
the value “<literal>2</literal>”, the third, “<literal>3</literal>”,
etc.</para>

<para>The result of the p:label-elements step is the input document with the
attribute labels associated with matched elements.  All other non-matching content
remains the same.</para>

<section>
<title>Document properties</title>
<para feature="label-elements-preserves-all">All document properties are preserved.</para>
</section>
</section>
<section xml:id="c.load">
<title>p:load</title>

<para>The <code>p:load</code> step has no inputs but produces as its
result a document (or documents) specified by an IRI.</para>

<p:declare-step type="p:load">
  <p:output port="result" sequence="true" content-types="*/*"/>
  <p:option name="href" required="true" as="xs:anyURI"/>
  <p:option name="parameters" as="map(xs:QName,item())"/>
  <p:option name="document-properties" as="map(xs:QName, item())"/>
</p:declare-step>

<para>The value of the <option>href</option> option
<rfc2119>must</rfc2119> be an <type>anyURI</type>. It is interpreted
as an IRI reference. If it is relative, it is made absolute against
the base URI of the element on which it is specified
(<tag>p:with-option</tag> or <tag>p:load</tag> in the case of a
<olink targetdoc="../xproc20/xproc20.xml" targetptr="option-shortcut">syntactic shortcut</olink> value).</para>

<para>The document or documents identified by the URI are loaded and
returned. If the URI protocol supports redirection, then redirects
<rfc2119>must</rfc2119> be followed.</para>

<para>The behavior of this step depends on the content type of the
document or documents loaded. The content type of each document is
determined as follows:</para>

<orderedlist>
<listitem>
<para>If a <property>content-type</property> property is specified
in <option>document-properties</option>, then each document
<rfc2119>must</rfc2119> be interpreted according to that content type.
</para>
</listitem>
<listitem>
<para>If the documents are retrieved with a URI protocol that specifies
a content type (for example, <literal>http:</literal>), then the document
<rfc2119>must</rfc2119> be interpreted according to that content type.
</para>
</listitem>
<listitem>
<para><impl>In the absence of an explicit type, the content
type is <glossterm>implementation-defined</glossterm></impl>.</para>
</listitem>
</orderedlist>

<para>The <option>parameters</option> map contains additional, optional
parameters that may influence the way that content is loaded. The interpretation
of this map varies according to the content type. Parameter names that are in
no namespace are treated as strings using only the local-name where appropriate.</para>

<para>Broadly speaking, there are four categories of data that might
be loaded:
<link linkend="c.load.xml">XML</link>,
<link linkend="c.load.text">text</link>,
<link linkend="c.load.json">JSON</link>, and “other”
<link linkend="c.load.binary">binary</link> data.</para>

<section xml:id="c.load.xml">
<title>Loading XML data</title>

<para>For an XML media type, the content is loaded and parsed as XML.</para>

<para>If the <option>dtd-validate</option> parameter is <literal>true</literal>,
then DTD validation must be performed when parsing the document.
<error code="D0043">It is a <glossterm>dynamic error</glossterm>
if the <option>dtd-validate</option> parameter is <literal>true</literal> and
the processor does not support DTD validation.</error></para>

<para><impl>Additional XML parameters are <glossterm>implementation-defined</glossterm>.
</impl></para>
</section>

<section xml:id="c.load.text">
<title>Loading text data</title>
<para>For a text media type, the content is loaded as a text document.</para>

<para><impl>Text parameters are <glossterm>implementation-defined</glossterm>.
</impl></para>

</section>

<section xml:id="c.load.json">
<title>Loading JSON data</title>

<para>For a JSON media type, the content is loaded and parsed as JSON.</para>

<para>The parameters specified for the <code>fn:parse-json</code> function
in <biblioref linkend="xpath-functions"/>
<rfc2119>must</rfc2119> be supported.
<impl>Additional JSON parameters are <glossterm>implementation-defined</glossterm>.
</impl></para>

</section>
<section xml:id="c.load.binary">
<title>Loading binary data</title>

<para>An XProc processor may load other, arbitrary data types. <impl>How a
processor interprets other media types is <glossterm>implementation-defined</glossterm>.
</impl>
<impl>Parameters for other media types
are <glossterm>implementation-defined</glossterm>.
</impl></para>
</section>

<section>
<title>Document properties</title>
<para feature="load-preserves-none">No document properties are preserved.
The properties specified in <option>document-properties</option> are applied.
</para>
</section>
</section>
<section xml:id="c.make-absolute-uris">
<title>p:make-absolute-uris</title>

<para>The <code>p:make-absolute-uris</code> step makes an element or
attribute's value in the source document an absolute IRI value in the
result document.</para>

<p:declare-step type="p:make-absolute-uris">
  <p:input port="source" content-types="application/xml text/xml */*+xml"/>
  <p:output port="result" content-types="application/xml"/>
  <p:option name="match" required="true" as="xs:string" e:type="XSLTMatchPattern"/>
  <p:option name="base-uri" as="xs:anyURI"/>
</p:declare-step>

<para>The value of the <option>match</option> option <rfc2119>must</rfc2119> be an
XSLTMatchPattern.
<error code="C0023">It is a <glossterm>dynamic error</glossterm> if
the pattern matches anything other than element or attribute
nodes.</error></para>

<para>The value of the <option>base-uri</option> option
<rfc2119>must</rfc2119> be an <type>anyURI</type>. It is interpreted
as an IRI reference. If it is relative, it is made absolute against
the base URI of the element on which it is specified
(<tag>p:with-option</tag> or <tag>p:make-absolute-uris</tag> in the case of
a <olink targetdoc="../xproc20/xproc20.xml" targetptr="option-shortcut">syntactic shortcut</olink>
value).</para>

<para>For every element or attribute in the input document which
matches the specified pattern, its XPath string-value is resolved
against the specified base URI and the resulting absolute IRI is used
as the matched node's entire contents in the output.</para>

<para>The base URI used for resolution defaults to the matched
attribute's element or the matched element's base URI unless the
<option>base-uri</option> option is specified. When the
<option>base-uri</option> option is specified, the option value is
used as the base URI regardless of any contextual base URI value in
the document. This option value is resolved against the base URI of
the <tag>p:option</tag> element used to set the option.</para>

<para><impl>If the IRI reference specified by the <option>base-uri</option> option
on <tag>p:make-absolute-uris</tag> is
not valid, or if it is absent and the input document has no base URI,
the results are <glossterm>implementation-dependent</glossterm>.</impl>
</para>

<section>
<title>Document properties</title>
<para feature="make-absolute-uris-preserves-all">All document properties are preserved.</para>
</section>
</section>
<section xml:id="c.namespace-rename">
<title>p:namespace-rename</title>

<para>The <code>p:namespace-rename</code> step renames any namespace declaration or
use of a namespace in a document to a new IRI value.</para>

 <p:declare-step type="p:namespace-rename">
   <p:input port="source" content-types="application/xml text/xml */*+xml"/>
   <p:output port="result" content-types="application/xml"/>
   <p:option name="from" as="xs:anyURI"/>
   <p:option name="to" as="xs:anyURI"/>
   <p:option name="apply-to" select="'all'" as="xs:token" e:type="all|elements|attributes"/>
</p:declare-step>

<para>The value of the <option>from</option> option
<rfc2119>must</rfc2119> be an <type>anyURI</type>. It
<rfc2119>should</rfc2119> be either empty or absolute, but will not be
resolved in any case.</para>

<para>The value of the <option>to</option> option
<rfc2119>must</rfc2119> be an <type>anyURI</type>. It
<rfc2119>should</rfc2119> be empty or absolute, but will not be
resolved in any case.</para>

<para>The value of the <option>apply-to</option> option
<rfc2119>must</rfc2119> be one of “<literal>all</literal>”,
“<literal>elements</literal>”, or “<literal>attributes</literal>”.
If the value is “<literal>elements</literal>”, only elements will be
renamed, if the value is “<literal>attributes</literal>”, only attributes
will be renamed, if the value is “<literal>all</literal>”, both elements
and attributes will be renamed.</para>

<para><error code="C0014">It is a <glossterm>dynamic error</glossterm>
if the XML namespace (<uri>http://www.w3.org/XML/1998/namespace</uri>)
or the XMLNS namespace (<uri>http://www.w3.org/2000/xmlns/</uri>) is
the value of either the <option>from</option> option or the
<option>to</option> option.</error></para>

<para>If the value of the <option>from</option> option is the same as
the value of the <option>to</option> option, the input is reproduced
unchanged on the output. Otherwise, namespace bindings, namespace
attributes and element and attribute names are changed as
follows:</para>

<itemizedlist>
  <listitem>
   <para>Namespace bindings:  If the <option>from</option> option is present
and its value is not the empty string,
then every binding of a prefix (or the default namespace) in the input
document whose value is the same as the value of the <option>from</option>
option is</para>
   <itemizedlist>
    <listitem>
     <para>replaced in the output with a binding to the value of the <option>to</option>
option, provided it is present and not the empty string;</para>
    </listitem>
    <listitem>
     <para>otherwise (the <option>to</option> option is
not specified or has an empty string as its value) absent from the output.</para>
    </listitem>
   </itemizedlist>
   <para>If the <option>from</option> option is absent, or its value is the empty string,
then no bindings are changed or removed.</para>
  </listitem>
  <listitem>
   <para>Elements and attributes: If the <option>from</option> option is present
and its value is not the empty string, for every element and attribute,
as appropriate, in the input whose namespace name is the same as the value of the
<option>from</option> option, in the output its namespace name is</para>
   <itemizedlist>
    <listitem>
     <para>replaced with the value of the <option>to</option>
option, provided it is present and not the empty string;</para>
    </listitem>
    <listitem>
     <para>otherwise (the <option>to</option> option is
not specified or has an empty string as its value) changed to have no value.</para>
    </listitem>
   </itemizedlist>
   <para>If the <option>from</option> option is absent, or its value
   is the empty string, then for every element and attribute, as appropriate,
   whose namespace name has no value, in the
   output its namespace name is set to the value of the
   <option>to</option> option.</para>
  </listitem>
  <listitem>
   <para>Namespace attributes:  If the <option>from</option> option is present
and its value is not the empty string, for every namespace attribute in the
input whose value is the same as the value of the <option>from</option> option, in the output</para>
   <itemizedlist>
    <listitem>
     <para>the namespace attribute's value is replaced with the value of the <option>to</option>
option, provided it is present and not the empty string;</para>
    </listitem>
    <listitem>
     <para>otherwise (the <option>to</option> option is
not specified or has an empty string as its value) the namespace attribute is absent.</para>
    </listitem>
   </itemizedlist>
  </listitem>
 </itemizedlist>

<note xml:id="note-apply-to">
<para>The <option>apply-to</option> option is primarily intended to make
it possible to avoid renaming attributes when the <option>from</option> option
specifies no namespace, since many attributes are in no namespace.</para>

<para>Care should be taken when specifying no namespace with the
<option>to</option> option.  Prefixed names in content, for example QNames and
XPath expressions, may end up with no appropriate namespace binding.</para></note>

<section>
<title>Document properties</title>
<para feature="namespace-rename-preserves-all">All document properties are preserved.</para>
</section>
</section>
<section xml:id="c.pack">
<title>p:pack</title>

<para>The <code>p:pack</code> step merges two document sequences in a pair-wise
fashion.</para>

<p:declare-step type="p:pack">
   <p:input port="source" content-types="application/xml text/xml */*+xml" sequence="true" primary="true"/>
   <p:input port="alternate" sequence="true" content-types="application/xml"/>
   <p:output port="result" sequence="true"/>
   <p:option name="wrapper" required="true" as="xs:QName"/>
   <p:option name="wrapper-prefix" as="xs:NCName"/>
   <p:option name="wrapper-namespace" as="xs:anyURI"/>
</p:declare-step>

<para>The value of the <option>wrapper</option> option
<rfc2119>must</rfc2119> be a <type>QName</type>. If the lexical value
does not contain a colon, then the <tag class="attribute">wrapper-namespace</tag>
may be used to specify the namespace of the wrapper. In that case, the
<tag class="attribute">wrapper-prefix</tag> may be specified to suggest a
prefix for the wrapper element.
<error code="D0034">It is a <glossterm>dynamic error</glossterm>
to specify a new namespace or prefix if the lexical value of the specified
name contains a colon.</error></para>

<para>The step takes each pair of documents, in order, one from the
<port>source</port> port and one from the <port>alternate</port> port,
wraps them with a new element node whose QName is the value specified
in the <option>wrapper</option> option, and writes that element to the
<port>result</port> port as a document.</para>

<para>If the step reaches the end of one input sequence before the
other, then it simply wraps each of the remaining documents in the
longer sequence.</para>

<note xml:id="note-two-docs">
<para>In the common case, where the document element of a document in
the <port>result</port> sequence has two element children, any
comments, processing instructions, or white space text nodes that
occur between them may have come from either of the input documents;
this step does not attempt to distinguish which one.</para>
</note>

<section>
<title>Document properties</title>
<para feature="pack-preserves-none">No document properties are preserved.</para>
</section>
</section>
<section xml:id="c.parameters">
<title>p:parameters</title>

<para>The <code>p:parameters</code> step exposes a set of parameters
as a <tag>c:param-set</tag> document.</para>

<p:declare-step type="p:parameters">
   <p:output port="result" content-types="application/xml"/>
   <p:option name="parameters" as="map(xs:QName,item())"/>
</p:declare-step>

<para>Each parameter in the <option>parameters</option> map is converted into a
<tag>c:param</tag> element.
The resulting <tag>c:param</tag> elements are wrapped in a
<tag>c:param-set</tag> and the parameter set document is written
to the <port>result</port> port.
<impl>The
order in which <tag>c:param</tag> elements occur in the <tag>c:param-set</tag> is
<glossterm>implementation-dependent</glossterm>.</impl></para>

<para>For consistency and user convenience, if any of the parameters
have names that are in a namespace, the
<tag class="attribute">namespace</tag> attribute on the
<tag>c:param</tag> element <rfc2119>must</rfc2119> be used. Each
<tag class="attribute">name</tag> <rfc2119>must</rfc2119> be an NCName.</para>

<para>The base URI of the output document is the URI of the pipeline document
that contains the step.</para>

<section xml:id="cv.param">
<title>The c:param element</title>

<para>A <tag>c:param</tag> represents a parameter on a parameter
input.</para>

<e:rng-pattern name="VocabParam"/>

<para>The <tag class="attribute">name</tag> attribute of the
<tag>c:param</tag> must have the lexical form of a QName.</para>

<para>If the <tag class="attribute">namespace</tag> attribute is
specified, then the expanded name of the parameter is constructed from
the specified namespace and the <tag class="attribute">name</tag>
value. <error code="D0025">It is a <glossterm>dynamic
error</glossterm> if the <tag class="attribute">namespace</tag>
attribute is specified, the <tag class="attribute">name</tag> contains
a colon, and the specified namespace is not the same as the in-scope
namespace binding for the specified prefix.</error>
</para>

<para>If the <tag class="attribute">namespace</tag> attribute is not
specified, and the <tag class="attribute">name</tag> contains a colon,
then the expanded name of the parameter is constructed using the <tag class="attribute">name</tag> value and the namespace declarations
in-scope on the <tag>c:param</tag> element.</para>

<para>If the <tag class="attribute">namespace</tag> attribute is not
specified, and the <tag class="attribute">name</tag> does not contain
a colon, then the expanded name of the parameter is in no
namespace.</para>

<para>Any namespace-qualified attribute names that appear on the
<tag>c:param</tag> element are ignored. <error code="D0014">It is a
<glossterm>dynamic error</glossterm> for any unqualified attribute
names other than “<literal>name</literal>”,
“<literal>namespace</literal>”, or “<literal>value</literal>” to
appear on a <tag>c:param</tag> element.</error></para>
</section>

<section xml:id="cv.param-set">
<title>The c:param-set element</title>

<para>A <tag>c:param-set</tag> represents a set of parameters on a
parameter input.</para>

<e:rng-pattern name="VocabParamSet"/>

<para>The <tag>c:param-set</tag> contains zero or more
<tag>c:param</tag> elements. <error code="D0018">It is a
<glossterm>dynamic error</glossterm> if the parameter list contains
any elements other than <tag>c:param</tag>.</error></para>

<para>Any namespace-qualified attribute names that appear on the
<tag>c:param-set</tag> element are ignored. <error code="D0014">It is
a <glossterm>dynamic error</glossterm> for any unqualified attribute
names to appear on a <tag>c:param-set</tag>
element.</error></para>
</section>

<section>
<title>Document properties</title>
<para feature="parameters-preserves-none">No document properties are preserved.</para>
</section>
</section>
<section xml:id="c.rename">
<title>p:rename</title>

<para>The <code>p:rename</code> step renames elements, attributes, or
processing-instruction targets in a document.</para>

<p:declare-step type="p:rename">
  <p:input port="source" content-types="application/xml text/xml */*+xml"/>
  <p:output port="result" content-types="application/xml"/>
  <p:option name="match" select="'/*'" as="xs:string" e:type="XSLTMatchPattern"/>
  <p:option name="new-name" required="true" as="xs:QName"/>
  <p:option name="new-prefix" as="xs:NCName"/>
  <p:option name="new-namespace" as="xs:anyURI"/>
</p:declare-step>

<para>The value of the <option>match</option> option must be an
XSLTMatchPattern. <error code="C0023">It is a <glossterm>dynamic
error</glossterm> if the pattern matches anything other than element,
attribute or processing instruction nodes.</error></para>

<para>The value of the <option>new-name</option> option must be a
<type>QName</type>.
If the lexical value does not contain a colon, then the <tag class="attribute">new-namespace</tag> may be used to specify the
namespace of the new name. In that case, the <tag class="attribute">new-prefix</tag> may be specified to suggest a
prefix for the new name. <error code="D0034">It is a
<glossterm>dynamic error</glossterm> to specify a new namespace or
prefix if the lexical value of the specified name contains a
colon.</error>
</para>

<para>Each element, attribute, or processing-instruction in the input
matched by the match pattern specified in the <option>match</option>
option is renamed in the output to the name specified by the
<option>new-name</option> option.</para>

<para>If the <option>match</option> option matches an attribute and if
the element on which it occurs already has an attribute whose expanded
name is the same as the expanded name of the specified
<option>new-name</option>, then the results is as if the current
attribute named “<replaceable>new-name</replaceable>” was deleted before
renaming the matched attribute.</para>

<para>With respect to attributes named “<literal>xml:base</literal>”, the
following semantics apply: renaming an <emphasis>from</emphasis>
“<literal>xml:base</literal>” <emphasis>to</emphasis> something else has
no effect on the underlying base URI of the element; however,
if an attribute is renamed <emphasis>from</emphasis> something else
<emphasis>to</emphasis> “<literal>xml:base</literal>”, the base URI
of the element <rfc2119>must</rfc2119> also be amended accordingly.</para>

<para>If the pattern matches processing instructions, then it is the
processing instruction target that is renamed. <error code="C0013">It
is a <glossterm>dynamic error</glossterm> if the pattern matches
a processing instruction and the new name has a non-null namespace.</error>
</para>

<section>
<title>Document properties</title>
<para feature="rename-preserves-all">All document properties are preserved.</para>
</section>
</section>
<section xml:id="c.replace">
<title>p:replace</title>

<para>The <code>p:replace</code> step replaces matching nodes in
its primary input with the document element of the
<code>replacement</code> port's document.</para>

<p:declare-step type="p:replace">
   <p:input port="source" primary="true" content-types="application/xml text/xml */*+xml"/>
   <p:input port="replacement" content-types="application/xml text/xml */*+xml"/>
   <p:output port="result" content-types="application/xml"/>
   <p:option name="match" required="true" as="xs:string" e:type="XSLTMatchPattern"/>
</p:declare-step>

<para>The value of the <option>match</option> option
<rfc2119>must</rfc2119> be an XSLTMatchPattern. <error code="C0023">It
is a <glossterm>dynamic error</glossterm> if that pattern matches
anything other than element, text, processing-instruction, or comment
nodes. </error> Multiple matches are allowed, in which case multiple
copies of the <port>replacement</port> document will occur.</para>

<para>Every node in the primary input matching the specified
pattern is replaced in the output is replaced by the document element
of the <port>replacement</port> document. Only non-nested matches are
replaced. That is, once a node is replaced, its descendants cannot
be matched.</para>

<section>
<title>Document properties</title>
<para feature="replace-preserves-all">All document properties are preserved.</para>
</section>
</section>
<section xml:id="c.set-attributes">
<title>p:set-attributes</title>

<para>The <tag>p:set-attributes</tag> step sets attributes on
matching elements.</para>

<p:declare-step type="p:set-attributes">
   <p:input port="source" primary="true" content-types="application/xml text/xml */*+xml"/>
   <p:input port="attributes" content-types="application/xml text/xml */*+xml"/>
   <p:output port="result" content-types="application/xml"/>
   <p:option name="match" select="'/*'" as="xs:string" e:type="XSLTMatchPattern"/>
</p:declare-step>

 <para>The value of the <option>match</option> option <rfc2119>must</rfc2119> be an
 XSLTMatchPattern. <error code="C0023">It is a <glossterm>dynamic
 error</glossterm> if that pattern matches anything other than element
 nodes.</error></para>

<para>Each attribute on the document element of the document that
appears on the <port>attributes</port> port is copied to each element
that matches the <option>match</option> expression.</para>

<para>If an attribute with the same name as one of the attributes to
be copied already exists, the value specified on the
<port>attribute</port> port's document is used. The result port of
this step produces a copy of the <port>source</port> port's document
with the matching elements' attributes modified.</para>

<para>The matching elements are specified by the match pattern in the
<option>match</option> option. All matching elements are processed.
If no elements match, the step will not change any elements.</para>

<para>This step must not copy namespace declarations.  If the attributes
copied from the <port>attributes</port> use namespaces, prefixes, or
prefixes bound to different namespaces, the document produced on the
<port>result</port> output port will require
<olink targetdoc="../xproc20/xproc20.xml" targetptr="namespace-fixup"/>.</para>

<para>If an attribute named
<tag class="attribute">xml:base</tag> is added or changed, the base URI
of the element <rfc2119>must</rfc2119> also be amended accordingly.</para>

<section>
<title>Document properties</title>
<para feature="set-attributes-preserves-all">All document properties are preserved.</para>
</section>
</section>
<section xml:id="c.set-properties">
<title>p:set-properties</title>

<para>The <tag>p:set-properties</tag> step sets <glossterm>document
properties</glossterm> on the source document.</para>

<p:declare-step type="p:set-properties">
   <p:input port="source" content-types="*/*"/>
   <p:output port="result" content-types="*/*"/>
   <p:option name="properties" required="true" as="map(xs:QName,item())"/>
   <p:option name="merge" default="false()" as="xs:boolean"/>
</p:declare-step>

 <para>The <glossterm>document properties</glossterm> of the document
on the <port>source</port> port are augmented with the values specified
in the <option>properties</option> option. The document produced on
the <port>result</port> port has the same representation but the
adjusted property values.</para>

<para feature="p-set-properties-merge">If the <option>merge</option>
option is true, then the supplied properties are added to the existing
properties. If it is false, the document’s properties are replaced by
the new set.</para>

<para><error code="C0069">It is a <glossterm>dynamic
error</glossterm> if the <option>properties</option> map contains
a key equal to the string “<literal>content-type</literal>”.</error>
</para>

<section>
<title>Document properties</title>
<para feature="set-properties-preserves-some">If <option>merge</option> is
true, document properties not overridden by settings in the <option>properties</option>
map are  preserved, otherwise the resulting document has the properties specified in
the <option>properties</option> map.
</para>
</section>
</section>
<section xml:id="c.sink">
<title>p:sink</title>

<para>The <tag>p:sink</tag> step accepts a sequence of documents and
discards them. It has no output.</para>

<p:declare-step type="p:sink">
   <p:input port="source" content-types="*/*" sequence="true"/>
</p:declare-step>

<section>
<title>Document properties</title>
<para feature="sing-preserves-na">Not applicable.</para>
</section>
</section>
<section xml:id="c.split-sequence">
<title>p:split-sequence</title>

<para>The <tag>p:split-sequence</tag> step accepts a sequence of
documents and divides it into two sequences.</para>

<p:declare-step type="p:split-sequence">
  <p:input port="source" content-types="application/xml text/xml */*+xml" sequence="true"/>
  <p:output port="matched" sequence="true" primary="true" content-types="application/xml"/>
  <p:output port="not-matched" sequence="true" content-types="application/xml"/>
  <p:option name="initial-only" select="false()" as="xs:boolean"/>
  <p:option name="test" required="true" as="xs:string" e:type="XPathExpression"/>
</p:declare-step>

 <para>The value of the <option>test</option> option <rfc2119>must</rfc2119> be an XPathExpression.</para>

<para>The XPath expression in the <option>test</option> option is
applied to each document in the input sequence. If the effective
boolean value of the expression is true, the document is copied to the
<port>matched</port> port; otherwise it is copied to the
<port>not-matched</port> port.</para>

<para>If the <option>initial-only</option> option is true, then when
the first document that does not satisfy the test expression is
encountered, it <emphasis>and all the documents that follow
it</emphasis> are written to the <port>not-matched</port> port.
In other words, it only writes the initial series of matched
documents (which may be empty) to the <port>matched</port> port.
All other documents are written to the <port>not-matched</port> port,
irrespective of whether or not they match.</para>

<para>The <olink targetdoc="../xproc20/xproc20.xml" targetptr="xpath-context">XPath context</olink> for the
<option>test</option> option changes over time. For each document that
appears on the <code>source</code> port, the expression is evaluated
with that document as the context document. The context position
(<code>position()</code>) is the position of that document within the
sequence and the context size (<code>last()</code>) is the total
number of documents in the sequence.</para>

<note xml:id="note-stream">
<para>In principle, this component cannot stream because it must
buffer all of the input sequence in order to find the context size. In
practice, if the test expression does not use the
<function>last()</function> function, the implementation can stream
and ignore the context size.</para>
</note>

<para>If the implementation supports passing PSVI annotations between
steps, the <tag>p:split-sequence</tag> step <rfc2119>must</rfc2119> preserve
any annotations that appear in the input.</para>

<section>
<title>Document properties</title>
<para feature="split-sequence-preserves-all">All document properties are preserved.</para>
</section>
</section>
<section xml:id="c.store">
<title>p:store</title>

<para>The <tag>p:store</tag> step stores (a possibly serialized
version of) its input to a URI. This step outputs a reference to the
location of the stored document.</para>

<p:declare-step type="p:store">
  <p:input port="source" content-types="*/*"/>
  <p:output port="result" content-types="application/xml"/>
  <p:option name="href" required="true" as="xs:anyURI"/>
  <p:option name="serialization" as="map(xs:string,xs:anyAtomicValue)"/>
</p:declare-step>

<para>The value of the <option>href</option> option
<rfc2119>must</rfc2119> be an <type>anyURI</type>. If it is relative,
it is made absolute against the base URI of the element on which it is
specified (<tag>p:with-option</tag> or <tag>p:store</tag> in the case
of a <olink targetdoc="../xproc20/xproc20.xml" targetptr="option-shortcut">syntactic shortcut</olink>
value).</para>

<para>The step attempts to store the XML document to the specified
URI. <error code="C0050">It is a <glossterm>dynamic error</glossterm>
if the URI scheme is not supported or the step cannot store to the
specified location.</error></para>

<para>The output of this step is a document containing a single
<tag>c:result</tag> element whose content is the absolute URI of the
document stored by the step.</para>

<para>The <option>serialization</option> option is provided to control the
serialization of content when it is stored. Serialization is described in
<link linkend="serialization">Serialization</link>.</para>

<section>
<title>Document properties</title>
<para feature="store-preserves-none">No document properties are preserved.</para>
</section>
</section>
<section xml:id="c.string-replace">
<title>p:string-replace</title>

<para>The <tag>p:string-replace</tag> step matches nodes in the
document provided on the <port>source</port> port and replaces them
with the string result of evaluating an XPath expression.</para>

<p:declare-step type="p:string-replace">
   <p:input port="source" content-types="application/xml text/xml */*+xml"/>
   <p:output port="result" content-types="application/xml"/>
   <p:option name="match" required="true" as="xs:string" e:type="XSLTMatchPattern"/>
   <p:option name="replace" required="true" as="xs:string" e:type="XPathExpression"/>
</p:declare-step>

<para>The value of the <option>match</option> option <rfc2119>must</rfc2119> be an
XSLTMatchPattern.</para>

<para>The value of the <option>replace</option> option <rfc2119>must</rfc2119> be an
XPathExpression.</para>

<para>The matched nodes are specified with the match pattern in the
<option>match</option> option.
For each matching node, the XPath
expression provided by the <option>replace</option> option is
evaluated with the matching node as the XPath context node.
The string value of the result is used in the output.
Nodes that do not match are copied without change.</para>

<para>If the expression given in the <option>match</option> option
matches an <emphasis>attribute</emphasis>, the string value of the
<option>replace</option>
expression is used as the new value of the attribute in the output.
If the attribute is named “<tag class="attribute">xml:base</tag>”, the base URI
of the element <rfc2119>must</rfc2119> also be amended accordingly.</para>

<para>If the expression matches any other kind of node, the entire
node (and <emphasis>not</emphasis> just its contents) is replaced by
the string value of the <option>replace</option> expression.</para>

<section>
<title>Document properties</title>
<para feature="string-replace-preserves-all">All document properties are preserved.</para>
</section>
</section>
<section xml:id="c.unescape-markup">
<title>p:unescape-markup</title>

<para>The <tag>p:unescape-markup</tag> step takes the string value of
the document element and parses the content as if it was a Unicode
character stream containing serialized XML. The output consists of the
same document element with children that result from the parse. This
is the reverse of the <tag>p:escape-markup</tag> step.</para>

<p:declare-step type="p:unescape-markup">
  <p:input port="source" content-types="application/xml text/xml */*+xml text/*"/>
  <p:output port="result" content-types="application/xml text/xml */*+xml"/>
  <p:option name="namespace" as="xs:anyURI"/>
  <p:option name="content-type" select="'application/xml'" as="xs:string"/>
  <p:option name="encoding" as="xs:string"/>
  <p:option name="charset" as="xs:string"/>
</p:declare-step>

<para>The value of the <option>namespace</option> option
<rfc2119>must</rfc2119> be an <type>anyURI</type>. It
<rfc2119>should</rfc2119> be absolute, but will not be
resolved.</para>

<para>When the string value is parsed, the original document element
is preserved so that the result will be well-formed XML even if the
content consists of multiple, sibling elements.</para>

<para>The <option>namespace</option> option specifies a default
namespace. Elements that are in no namespace in the unescaped content
will be placed into this namespace unless there is an in-scope namespace
declaration that specifies a different namespace (or explicitly undeclares
the default namespace).</para>

<para>The <option>content-type</option> option <rfc2119>may</rfc2119>
be used to specify an alternate content type for the string value. An
implementation <rfc2119>may</rfc2119> use a different parser to
produce XML content depending on the specified content-type. For
example, an implementation might provide an HTML to XHTML parser (e.g.
<biblioref linkend="tidy"/> or <biblioref linkend="tagsoup"/>) for the
content type '<literal>text/html</literal>'.</para>

<para>All implementations <rfc2119>must</rfc2119> support the content
type <literal>application/xml</literal>, and must use a standard XML
parser for it. <error code="C0051">It is a <glossterm>dynamic
error</glossterm> if the content-type specified is not supported by
the implementation.</error>
<impl>Behavior of
<tag>p:unescape-markup</tag> for <option>content-type</option>s other
than <literal>application/xml</literal> is
<glossterm>implementation-defined</glossterm>.</impl></para>

<para>The <option>encoding</option> option specifies how the data is
encoded. All implementations <rfc2119>must</rfc2119> support the
<literal>base64</literal> encoding (and the absence of an encoding
option, which implies that the content is plain Unicode text).
<error code="C0052">It is a <glossterm>dynamic error</glossterm> if the
encoding specified is not supported by the
implementation.</error></para>

<para>If an <option>encoding</option> is specified, a
<option>charset</option> may also be specified.
The character set may be specified as a parameter on the
<option>content-type</option> or via the separate
<option>charset</option> option. If it is specified in both places,
the value of the <option>charset</option> option
<rfc2119>must</rfc2119> be used.</para>

<para>If the specified
<option>encoding</option> is <literal>base64</literal>,
then the character set
<rfc2119>must</rfc2119> be specified.
<error code="C0010">It is a <glossterm>dynamic error</glossterm>
if an encoding of <literal>base64</literal> is specified and
the character set is not specified or if the specified
character set is not supported by the implementation.</error>
</para>

<para>The octet-stream that results from decoding the
text <rfc2119>must</rfc2119> be interpreted using the character encoding named by
the value of the <option>charset</option> option
to produce a sequence of Unicode characters to parse.</para>

<para>If no <option>encoding</option> is specified, the character set
is ignored, irrespective of where it was specified.</para>

<para>For example, with the 'namespace' option set to the XHTML
namespace, the following input:</para>

<programlisting language="xml">&lt;description&gt;
&amp;lt;p&gt;This is a chunk.&amp;lt;/p&gt;
&amp;lt;p&gt;This is a another chunk.&amp;lt;/p&gt;
&lt;/description&gt;</programlisting>

<para>would produce:</para>

<programlisting language="xml">&lt;description&gt;
&lt;p xmlns="http://www.w3.org/1999/xhtml"&gt;This is a chunk.&lt;/p&gt;
&lt;p xmlns="http://www.w3.org/1999/xhtml"&gt;This is a another chunk.&lt;/p&gt;
&lt;/description&gt;</programlisting>

<section>
<title>Document properties</title>
<para feature="unescape-markup-preserves-none">No document properties are preserved.</para>
</section>
</section>
<section xml:id="c.unwrap">
<title>p:unwrap</title>

<para>The <tag>p:unwrap</tag> step replaces matched elements with their
children.</para>

<p:declare-step type="p:unwrap">
   <p:input port="source" content-types="application/xml text/xml */*+xml"/>
   <p:output port="result" content-types="application/xml"/>
   <p:option name="match" select="'/*'" as="xs:string" e:type="XSLTMatchPattern"/>
</p:declare-step>

 <para>The value of the <option>match</option> option <rfc2119>must</rfc2119> be an
 XSLTMatchPattern. <error code="C0023">It is a <glossterm>dynamic
 error</glossterm> if that pattern matches anything other than element
 nodes.</error></para>

<para>Every element in the <port>source</port> document that matches
the specified <option>match</option> pattern is replaced by its children,
effectively “unwrapping” the children from their parent. Non-element nodes
and unmatched elements are passed through unchanged.</para>

<note xml:id="note-match-doc">
<para>The matching applies to the entire document, not just the “top-most”
matches. A pattern of the form <literal>h:div</literal> will replace
<emphasis>all</emphasis> <tag>h:div</tag> elements, not just the top-most
ones.</para>
</note>

<para>This step produces a single document; if the document element is
unwrapped, the result might not be well-formed XML.</para>

<section>
<title>Document properties</title>
<para feature="unwrap-preserves-none">No document properties are preserved.</para>
</section>
</section>
<section xml:id="c.wrap">
<title>p:wrap</title>

<para>The <tag>p:wrap</tag> step wraps matching nodes in the
<port>source</port> document with a new parent element.</para>

<p:declare-step type="p:wrap">
   <p:input port="source" content-types="application/xml text/xml */*+xml"/>
   <p:output port="result" content-types="application/xml"/>
   <p:option name="wrapper" required="true" as="xs:QName"/>
   <p:option name="wrapper-prefix" as="xs:NCName"/>
   <p:option name="wrapper-namespace" as="xs:anyURI"/>
   <p:option name="match" required="true" as="xs:string" e:type="XSLTMatchPattern"/>
   <p:option name="group-adjacent" as="xs:string" e:type="XPathExpression"/>
</p:declare-step>

<para>The value of the <option>wrapper</option> option
<rfc2119>must</rfc2119> be a <type>QName</type>. If the lexical value
does not contain a colon, then the <tag class="attribute">wrapper-namespace</tag>
may be used to specify the namespace of the wrapper. In that case, the
<tag class="attribute">wrapper-prefix</tag> may be specified to suggest a
prefix for the wrapper element.
<error code="D0034">It is a <glossterm>dynamic error</glossterm>
to specify a new namespace or prefix if the lexical value of the specified
name contains a colon.</error></para>

<para>The value of the <option>match</option> option
<rfc2119>must</rfc2119> be an XSLTMatchPattern. <error code="C0023">It
is a <glossterm>dynamic error</glossterm> if the pattern matches
anything other than document, element, text, processing instruction, and comment
nodes.</error>
</para>

<para>The value of the <option>group-adjacent</option> option
<rfc2119>must</rfc2119> be an XPathExpression.</para>

<para>If the node matched is the document node (<code>match="/"</code>),
the result is a new document where the document element is a new
element node whose QName is the value specified in the
<option>wrapper</option> option. That new element contains copies of
all of the children of the original document node.</para>

<para>When the match pattern does not match the document node,
every node that matches the specified <option>match</option>
pattern is replaced with a new element node whose QName is the value
specified in the <option>wrapper</option> option.
The content of that new element is a copy of the original,
matching node. The <tag>p:wrap</tag> step performs a "deep" wrapping, the children
of the matching node and their descendants are processed and wrappers
are added to all matching nodes.
</para>

<para>The <option>group-adjacent</option> option can be used to group
adjacent matching nodes in a single wrapper element. The specified
XPath expression is evaluated for each matching node with that node
as the XPath context node. Whenever two or more adjacent matching nodes
have the same “group adjacent” value, they are wrapped together in
a single wrapper element.</para>

<para>Two matching nodes are considered adjacent if and only if they
are siblings and either there are no nodes between them or all
intervening, non-matching nodes are whitespace text, comment, or processing
instruction nodes.</para>

<section>
<title>Document properties</title>
<para feature="wrap-preserves-none">No document properties are preserved.</para>
</section>
</section>
<section xml:id="c.wrap-sequence">
<title>p:wrap-sequence</title>

<para>The <tag>p:wrap-sequence</tag> step accepts a sequence of
documents and produces either a single document or a new sequence of
documents.</para>

<p:declare-step type="p:wrap-sequence">
   <p:input port="source" content-types="application/xml text/xml */*+xml" sequence="true"/>
   <p:output port="result" sequence="true" content-types="application/xml"/>
   <p:option name="wrapper" required="true" as="xs:QName"/>
   <p:option name="wrapper-prefix" as="xs:NCName"/>
   <p:option name="wrapper-namespace" as="xs:anyURI"/>
   <p:option name="group-adjacent" as="xs:string" e:type="XPathExpression"/>
</p:declare-step>

<para>The value of the <option>wrapper</option> option
<rfc2119>must</rfc2119> be a <type>QName</type>. If the lexical value
does not contain a colon, then the <tag class="attribute">wrapper-namespace</tag>
may be used to specify the namespace of the wrapper. In that case, the
<tag class="attribute">wrapper-prefix</tag> may be specified to suggest a
prefix for the wrapper element.
<error code="D0034">It is a <glossterm>dynamic error</glossterm>
to specify a new namespace or prefix if the lexical value of the specified
name contains a colon.</error></para>

<para>The value of the <option>group-adjacent</option> option
<rfc2119>must</rfc2119> be an XPathExpression.</para>

<para>In its simplest form, <tag>p:wrap-sequence</tag> takes a
sequence of documents and produces a single, new document by placing
each document in the <port>source</port> sequence inside a new
document element as sequential siblings. The name of the document
element is the value specified in the <option>wrapper</option>
option.</para>

<para>The <option>group-adjacent</option> option can be used to group
adjacent documents.
The
<olink targetdoc="../xproc20/xproc20.xml" targetptr="xpath-context">XPath
context</olink> for the
<option>group-adjacent</option> option changes over time. For each document that
appears on the <code>source</code> port, the expression is evaluated
with that document as the context document. The context position
(<code>position()</code>) is the position of that document within the
sequence and the context size (<code>last()</code>) is the total
number of documents in the sequence.
Whenever
two or more sequentially adjacent documents have the same “group
adjacent” value, they are wrapped together in a single wrapper
element.
</para>

<section>
<title>Document properties</title>
<para feature="wrap-sequence-preserves-none">No document properties are preserved.</para>
</section>
</section>
<section xml:id="c.xinclude">
<title>p:xinclude</title>

<para>The <tag>p:xinclude</tag> step applies <biblioref linkend="xinclude"/> processing to the <port>source</port> document.</para>

<p:declare-step type="p:xinclude">
  <p:input port="source" content-types="application/xml text/xml */*+xml"/>
  <p:output port="result" content-types="application/xml text/xml */*+xml"/>
  <p:option name="fixup-xml-base" select="'false'" as="xs:boolean"/>
  <p:option name="fixup-xml-lang" select="'false'" as="xs:boolean"/>
</p:declare-step>

<para>The value of the <option>fixup-xml-base</option> option <rfc2119>must</rfc2119> be a
boolean. If it is true, base URI fixup will be performed as per
<biblioref linkend="xinclude"/>.</para>

<para>The value of the <option>fixup-xml-lang</option> option <rfc2119>must</rfc2119> be a
boolean. If it is true, language fixup will be performed as per
<biblioref linkend="xinclude"/>.</para>

<para>The included documents are located with the base URI of the
input document and are not provided as input to the step.</para>

<para><error code="C0029">It is a <glossterm>dynamic error</glossterm>
if an XInclude error occurs during processing.</error> </para>

<section>
<title>Document properties</title>
<para feature="xinclude-preserves-all">All document properties are preserved.</para>
</section>
</section>
<section xml:id="c.xslt">
<title>p:xslt</title>

<para>The <tag>p:xslt</tag> step applies an
<biblioref linkend="xslt10"/> or
<biblioref linkend="xslt20"/> stylesheet to a document.</para>

<p:declare-step type="p:xslt">
  <p:input port="source" content-types="application/xml text/xml */*+xml" sequence="true" primary="true"/>
  <p:input port="stylesheet" content-types="application/xml text/xml */*+xml"/>
  <p:option name="parameters" as="map(xs:QName,item())"/>
  <p:output port="result" primary="true" sequence="true" content-types="*/*"/>
  <p:output port="secondary" sequence="true"/>
  <p:option name="initial-mode" as="xs:QName"/>
  <p:option name="template-name" as="xs:QName"/>
  <p:option name="output-base-uri" as="xs:anyURI"/>
  <p:option name="version" as="xs:string"/>
</p:declare-step>

<para>If present, the value of the <option>initial-mode</option>
option <rfc2119>must</rfc2119> be a <type>QName</type>.</para>

<para>If present, the value of the <option>template-name</option>
option <rfc2119>must</rfc2119> be a <type>QName</type>.</para>

<para>If present, the value of the <option>output-base-uri</option>
option <rfc2119>must</rfc2119> be an <type>anyURI</type>. If it is
relative, it is made absolute against the base URI of the element on
which it is specified (<tag>p:with-option</tag> or <tag>p:xslt</tag> in the
case of a <olink targetdoc="../xproc20/xproc20.xml" targetptr="option-shortcut">syntactic shortcut</olink>
value).</para>

<para>If the step specifies a <option>version</option>, then that version
of XSLT <rfc2119>must</rfc2119> be used to process the transformation.
<error code="C0038">It is a
<glossterm>dynamic error</glossterm> if the specified version
is not available.</error> If the step does not specify a version, the
implementation may use any version it has available and may use any means
to determine what version to use, including, but not limited to,
examining the version of the stylesheet.</para>

<para>The XSLT stylesheet provided on the <port>stylesheet</port> port
is applied to the document on the <port>source</port> port. Any
parameters passed in the <option>parameters</option> option are used
to define top-level stylesheet parameters. The primary result document
of the transformation, if there is one, appears on the
<port>result</port> port. At most one document can appear on the
<port>result</port> port. All other result documents appear on the
<port>secondary</port> port. <impl>The order in which result documents
appear on the <port>secondary</port> port is
<glossterm>implementation-dependent</glossterm>.</impl> If XSLT 1.0 is
used, an empty sequence of documents <rfc2119>must</rfc2119> appear on
the <port>secondary</port> port.</para>

<para>If a sequence of documents is provided on the
<port>source</port> port, the first document is used as the
primary input document. The whole sequence is also the default
collection.
If no documents are provided on the <port>source</port> port,
the primary input document is undefined and the default collection
is empty.
<error code="C0039">It is a
<glossterm>dynamic error</glossterm> if a sequence of documents (including
an empty sequence) is provided
to an XSLT 1.0 step.</error>
</para>

<para>A dynamic error occurs if the XSLT processor signals a fatal
error. This includes the case where the transformation terminates due
to a <tag>xsl:message</tag> instruction with a <tag class="attribute">terminate</tag> attribute value of
“<literal>yes</literal>”. <impl>How XSLT message termination
errors are reported to the XProc processor is
<glossterm>implementation-dependent</glossterm>.</impl></para>

<para>The invocation of the transformation is controlled by the
<option>initial-mode</option> and <option>template-name</option>
options that set the initial mode and/or named template in the XSLT
transformation where processing begins. <error code="C0056">It is a
<glossterm>dynamic error</glossterm> if the specified initial mode
or named template cannot be applied to the specified stylesheet.</error>
</para>

<para>The <option>output-base-uri</option> option sets the context's
output base URI per the XSLT 2.0 specification, otherwise the base URI
of the <port>result</port> document is the base URI of the first
document in the <code>source</code> port's sequence. If the value of
the <option>output-base-uri</option> option is not absolute, it will
be resolved using the base URI of its <tag>p:option</tag>
element. An XSLT 1.0 step <rfc2119>should</rfc2119> use the value of the
<option>output-base-uri</option> as the base URI of its output, if the
option is specified.</para>

<para>If XSLT 2.0 is used, the outputs of this step
<rfc2119>may</rfc2119> include PSVI annotations.</para>


<para>The static and initial dynamic contexts of the XSLT processor
are the contexts defined in
<olink targetdoc="../xproc20/xproc20.xml" targetptr="step-xpath-context-20"/>
with the following adjustments.</para>

<para>The dynamic context is augmented as follows:</para>

<variablelist>
<varlistentry>
<term>Context item</term>
<listitem>
<para>The first document that appears on the <port>source</port> port.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Variable values</term>
<listitem>
<para>Any parameters
passed in the <option>parameters</option> option are available as variable bindings
to the XSLT processor.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Function implementations</term>
<listitem>
<para>The function implementations provided by the XSLT processor.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Default collection</term>
<listitem>
<para>The sequence of documents provided on the <port>source</port> port.
</para>
</listitem>
</varlistentry>
</variablelist>

<section>
<title>Document properties</title>
<para feature="xslt-preserves-none">No document properties are preserved.</para>
</section>
</section>
</section>

<section xml:id="std-optional">
<title>Optional Steps</title>

<para>The following steps are optional. If they are supported by a
processor, they must conform to the semantics outlined here, but a
conformant processor is not required to support all (or any) of these
steps.</para>

<section xml:id="c.exec">
<title>p:exec</title>

<para>The <tag>p:exec</tag> step runs an external command passing the
input that arrives on its <port>source</port> port as standard input,
reading <port>result</port> from standard output, and <port>errors</port>
from standard error.</para>

<p:declare-step type="p:exec">
  <p:input port="source" primary="true" sequence="true" content-types="*/*"/>
  <p:output port="result" primary="true" content-types="*/*"/>
  <p:output port="errors"/>
  <p:output port="exit-status"/>
  <p:option name="command" required="true" as="xs:string"/>
  <p:option name="args" select="''" as="xs:string"/>
  <p:option name="cwd" as="xs:string"/>
  <p:option name="source-is-xml" select="true()" as="xs:boolean"/>
  <p:option name="result-is-xml" select="true()" as="xs:boolean"/>
  <p:option name="wrap-result-lines" select="false()" as="xs:boolean"/>
  <p:option name="errors-is-xml" select="false()" as="xs:boolean"/>
  <p:option name="wrap-error-lines" select="false()" as="xs:boolean"/>
  <p:option name="path-separator" as="xs:string"/>
  <p:option name="failure-threshold" as="xs:integer"/>
  <p:option name="arg-separator" select="' '" as="xs:string"/>
  <p:option name="serialization" as="map(xs:string,xs:anyAtomicValue)"/>
</p:declare-step>

<para>The values of the <option>command</option>, <option>args</option>,
<option>cwd</option>, <option>path-separator</option>, and
<option>arg-separator</option> options <rfc2119>must</rfc2119> be strings.</para>

<para>The values of the <option>source-is-xml</option>,
<option>result-is-xml</option>, <option>errors-is-xml</option>,
and <option>fix-slashes</option> options <rfc2119>must</rfc2119> be
boolean.</para>

<para>The <tag>p:exec</tag> step executes the command passed on
<option>command</option> with the arguments passed on
<option>args</option>. The processor does not interpolate the values
of the <option>command</option> or <option>args</option> (for example,
expanding references to environment variables).
<error code="C0033">It is a <glossterm>dynamic
error</glossterm> if the command cannot be run.</error>
</para>

<para>If <option>cwd</option> is specified, then the current working
directory is changed to the value of that option before execution
begins. <error code="C0034">It is a <glossterm>dynamic
error</glossterm> if the current working directory cannot be changed
to the value of the <option>cwd</option> option.</error>
<impl>If <option>cwd</option> is not
specified, the current working directory is
<glossterm>implementation-defined</glossterm>.</impl></para>

<para>If the <option>path-separator</option> option is specified,
every occurrence of the character identified as the
<option>path-separator</option> character that occurs in the
<option>command</option>, <option>args</option>, or
<option>cwd</option> will be replaced by the platform-specific path
separator character. <error code="C0063">It is a <glossterm>dynamic
error</glossterm> if the <option>path-separator</option> option is
specified and is not exactly one character long.</error>
</para>

<para>The value of the <option>args</option> option is a string. In
order to support passing more than one argument to a command, the
<option>args</option> string is broken into a sequence of values.
The <option>arg-separator</option> option specifies the character
that is used to separate values; by default it is a single space
<error code="C0066">It is a <glossterm>dynamic error</glossterm> if
the <option>arg-separator</option> option is specified and is not
exactly one character long.</error>
</para>

<para>The following examples of <tag>p:exec</tag> are equivalent. The
first uses the default <option>arg-separator</option>:</para>

<programlisting language="xml">&lt;p:exec command="someCommand" args="arg1 arg2 arg3"/&gt;</programlisting>

<para>The second specifies an alternate separator:</para>

<programlisting language="xml">&lt;p:exec command="someCommand" args="arg1,arg2,arg3"
	arg-separator=","/&gt;</programlisting>

<para>If one of the arguments contains a space (e.g., a filename that
contains a space), then you must specify an alternate separator.</para>

<para>The <port>source</port> port is declared to accept a sequence so
that it can be empty. If no document appears on the
<port>source</port> port, then the command receives nothing on
standard input. If a document does arrive on the <port>source</port>
port, it will be passed to the command as its standard input. <error code="D0006">It is a <glossterm>dynamic error</glossterm> if more than
one document appears on the <port>source</port> port of the
<tag>p:exec</tag> step.</error>
If <option>source-is-xml</option> is true, the value of the
<option>serialization</option> option is used to convert the input
into serialized XML which is passed to the command, otherwise the
XPath string-value of the document is passed. Serialization is
described in
<link linkend="serialization">Serialization</link>.</para>

<para>The standard output of the command is read and returned on
<port>result</port>; the standard error output is read and returned on
<port>errors</port>. In order to assure that the result will be an
XML document, each of the results will be wrapped in a <tag>c:result</tag>
element.</para>

<para>If <option>result-is-xml</option> is true, the standard output of
the program is assumed to be XML and will be parsed as a single document.
If it is false, the output is assumed <emphasis>not</emphasis> to be XML
and will be returned as escaped text.</para>

<para xml:id="cv.line">If <option>wrap-result-lines</option> is
true, a <tag>c:line</tag> element will be wrapped around each line of output.</para>

<e:rng-pattern name="VocabLine"/>

<para><error code="C0035">It is a <glossterm>dynamic
error</glossterm> to specify both <option>result-is-xml</option> and
<option>wrap-result-lines</option>.</error></para>

<para>The same rules apply to the
standard error output of the program, with the <option>errors-is-xml</option>
and <option>wrap-error-lines</option> options, respectively.</para>

<para>If either of the results are XML, they <rfc2119>must</rfc2119> be
parsed with namespaces enabled and validation turned off, just like
<tag>p:document</tag>.</para>

<para>The <port>exit-status</port> port always returns a single
<tag>c:result</tag> element which contains the system exit status that
the process returned. <impl>The specific exit status values returned by
a process invoked with <tag>p:exec</tag> are
<glossterm>implementation-dependent</glossterm>.</impl></para>

<para>If a <option>failure-threshold</option> value is supplied, and the
exit status is greater than that threshold, then the <tag>p:exec</tag>
step <rfc2119>must</rfc2119> fail.
<error code="C0064">It is a <glossterm>dynamic
error</glossterm> if the exit code from the command is greater than
the specified <option>failure-threshold</option> value.</error>
This failure, like any step failure,
can be captured with a <tag>p:try</tag>.</para>

<section>
<title>Document properties</title>
<para feature="exec-preserves-none">No document properties are preserved.</para>
</section>
</section>
<section xml:id="c.hash">
<title>p:hash</title>

<para>The <tag>p:hash</tag> step generates a hash, or digital “fingerprint”,
for some value and injects it into the <port>source</port> document.</para>

<p:declare-step type="p:hash">
  <p:input port="source" primary="true" content-types="*/*"/>
  <p:output port="result" content-types="application/xml"/>
  <p:option name="parameters" as="map(xs:QName,item())"/>
  <p:option name="value" required="true" as="xs:string"/>
  <p:option name="algorithm" required="true" as="xs:QName"/>
  <p:option name="match" select="'/*'" as="xs:string" e:type="XSLTMatchPattern"/>
  <p:option name="version" as="xs:string"/>
</p:declare-step>

<para>The value of the <option>algorithm</option> option must be a QName.
If it does not have a prefix, then it must be one of the following values:
“crc”, “md”, or “sha”.</para>

<para>If a <tag class="attribute">version</tag> is not specified, the
default version is algorithm-defined. For “<literal>crc</literal>” it
is 32, for “<literal>md</literal>” it is 5, for “<literal>sha</literal>”
it is 1.</para>

<para>A hash is constructed from the string specified in the
<option>value</option> option using the specified algorithm and version.
Implementations <rfc2119>must</rfc2119> support
<biblioref linkend="bib.crc"/>,
<biblioref linkend="rfc1321"/>, and <biblioref linkend="bib.sha"/>
hashes. <impl>It is
<glossterm>implementation-defined</glossterm> what other algorithms are
supported.</impl>
The resulting hash <rfc2119>should</rfc2119> be returned as a string of
hexadecimal characters.
</para>

<para>The value of the <option>match</option> option must be an
XSLTMatchPattern.</para>

<para>The hash of the specified value is computed using the algorithm and
parameters specified. <error code="C0036">It is a
<glossterm>dynamic error</glossterm> if the requested hash algorithm is not
one that the processor understands or if the value or parameters are
not appropriate for that algorithm.</error></para>

<para>The matched nodes are specified with the match pattern in the
<option>match</option> option. For each matching node, the string
value of the computed hash is used in the output (if more than one node
matches, the <emphasis>same</emphasis> hash value is used in each match).
Nodes that do not
match are copied without change.</para>

<para>If the expression given in the <option>match</option> option
matches an <emphasis>attribute</emphasis>, the hash is used as the new
value of the attribute in the output.
If the attribute is named “<tag class="attribute">xml:base</tag>”, the base URI
of the element <rfc2119>must</rfc2119> also be amended accordingly.</para>

<para>If the expression matches any
other kind of node, the entire node (and <emphasis>not</emphasis> just
its contents) is replaced by the hash.</para>

<section>
<title>Document properties</title>
<para feature="hash-preserves-all">All document properties are preserved.</para>
</section>
</section>
<section xml:id="c.in-scope-names">
<title>p:in-scope-names</title>

<para>The <code>p:in-scope-names</code> step exposes all of the
in-scope variables and options as a set of parameters in a
<tag>c:param-set</tag> document.</para>

<p:declare-step type="p:in-scope-names">
  <p:output port="result" primary="false" content-types="application/xml"/>
</p:declare-step>

<para>Each in-scope variable and option is converted into a
<tag>c:param</tag> element.
The resulting <tag>c:param</tag> elements are wrapped in a 
<tag>c:param-set</tag> and the parameter set document is written
to the <port>result</port> port.
<impl>The
order in which <tag>c:param</tag> elements occur in the <tag>c:param-set</tag> is
<glossterm>implementation-dependent</glossterm>.</impl></para>

<para>For consistency and user convenience, if any of the variables or options
have names that are in a namespace, the
<tag class="attribute">namespace</tag> attribute on the
<tag>c:param</tag> element <rfc2119>must</rfc2119> be used. Each
<tag class="attribute">name</tag> <rfc2119>must</rfc2119> be an NCName.</para>

<para>The base URI of the output document is the URI of the pipeline document
that contains the step.</para>

<para>For consistency with the <tag>p:parameters</tag> step, the
<port>result</port> port is not primary.</para>

<section xml:id="ex-in-scope-names" role="tocsuppress">
<title>Example</title>

<para>This unlikely pipeline demonstrates the behavior of <tag>p:in-scope-names</tag>:
</para>

<programlisting>&lt;p:declare-step xmlns:p="http://www.w3.org/ns/xproc"
                name="main" version="1.0"&gt;
&lt;p:output port="result"&gt;
  &lt;p:pipe step="vars" port="result"/&gt;
&lt;/p:output&gt;

&lt;p:option name="username" required="true"/&gt;
&lt;p:option name="password" required="true"/&gt;
&lt;p:variable name="host" select="'http://example.com/'"/&gt;

&lt;p:in-scope-names name="vars"/&gt;

&lt;/p:declare-step&gt;</programlisting>

<para>Assuming the values supplied for the username and password
options are “<literal>user</literal>” and “<literal>pass</literal>”,
respectively, the output would be:</para>

<programlisting>&lt;c:param-set xmlns:c="http://www.w3.org/ns/xproc-step"&gt;
  &lt;c:param name="username" namespace="" value="user"/&gt;
  &lt;c:param name="host" namespace="" value="http://example.com/"/&gt;
  &lt;c:param name="password" namespace="" value="pass"/&gt;
&lt;/c:param-set&gt;</programlisting>

</section>

<section>
<title>Document properties</title>
<para feature="in-scope-names-preserves-none">No document properties are preserved.</para>
</section>
</section>
<section xml:id="c.template" role="ext-optional">
<title>p:template</title>

<para>The <code>p:template</code> replaces each XPath expression, delimited with
curly braces, in the <port>template</port> document with the result of evaluating that
expression.</para>

<p:declare-step type="p:template">
  <p:input port="source" sequence="true" primary="true" content-types="application/xml text/xml */*+xml"/>
  <p:input port="template" content-types="application/xml text/xml */*+xml"/>
  <p:output port="result" content-types="application/xml"/>
  <p:option name="parameters" as="map(xs:QName,item())"/>
</p:declare-step>

<para>While evaluating each expression, the names of any parameters passed to the
step are available as variable values in the XPath dynamic context.</para>

<para>The step searches for XPath expressions in attribute values,
text content (adjacent text nodes, if they occur in the data model,
must be coalesced; this step always processes maximal length text
nodes), processing instruction data, and comments. XPath expressions
are identified by curly braces, similar to attribute value templates
in XSLT or enclosed expressions in XQuery.</para>

<para>In order to allow curly braces to appear literally in content, they can be escaped
by doubling them. In other words, where “<code>{</code>” would start an XPath expression,
“<code>{{</code>” is simply a <emphasis>single</emphasis>, literal opening curly brace.
The same applies for closing curly braces.</para>

<para>Inside an XPath expression, strings quoted by single (<code>'</code>) or
double (<code>"</code>) quotes are treated literally. Outside of quoted text, it
is an error for an opening curly brace to occur. A closing curly brace ends the
XPath expression (whether or not it is followed immediately by another closing
curly brace).</para>

<para>These parsing rules can be described by the following algorithm, though implementations
are by no means required to implement the parsing in exactly this way, provided that they
achieve the same results.</para>

<itemizedlist>
<listitem><para>The parser begins in <emphasis>regular-mode</emphasis> at the start of
each unit of content where expansion may occur. In <emphasis>regular-mode</emphasis>:
</para>
<orderedlist>
<listitem><para>“<code>{{</code>” is replaced by a single “<code>{</code>”.</para></listitem>
<listitem><para>“<code>}}</code>” is replaced by a single “<code>}</code>”.
</para>
<para>Note:
<error code="C0067">It is a <glossterm>dynamic error</glossterm> to
encounter a single closing curly brace “<code>}</code>” that is not immediately
followed by another closing curly brace.</error>
</para></listitem>
<listitem><para>A single opening curly brace “<code>{</code>” (not
immediately followed by another opening curly brace) is discarded and
the parser moves into <emphasis>xpath-mode</emphasis>. The inital expression is empty.
</para></listitem>
<listitem><para>All other characters are copied without change.</para></listitem>
</orderedlist>
</listitem>
<listitem>
<para>In <emphasis>xpath-mode</emphasis>:</para>
<orderedlist>
<listitem><para><error code="C0067">It is a <glossterm>dynamic error</glossterm> to
encounter an opening curly brace “<code>{</code>”.</error></para></listitem>
<listitem><para>A closing curly brace “<code>}</code>” is discarded and ends the
expression. The expression is evaluated and the result of that
evaluation is copied to the output. The parser returns to
<emphasis>regular-mode</emphasis>.</para>
<para>Note: Braces cannot be escaped by doubling them
in <emphasis>xpath-mode</emphasis>.</para></listitem>
<listitem><para>A single quote (<code>'</code>) is added to the current expression and
the parser moves to <emphasis>single-quote-mode</emphasis>.</para></listitem>
<listitem><para>A double quote (<code>"</code>) is added to the current expression and
the parser moves to <emphasis>double-quote-mode</emphasis>.</para></listitem>
<listitem><para>All other characters are appended to the current expression.</para></listitem>
</orderedlist>
</listitem>
<listitem>
<para>In <emphasis>single-quote-mode</emphasis>:</para>
<orderedlist>
<listitem><para>A single quote (<code>'</code>) is added to the current expression and
the parser moves to <emphasis>xpath-mode</emphasis>.</para></listitem>
<listitem><para>All other characters are appended to the current expression.</para></listitem>
</orderedlist>
</listitem>
<listitem>
<para>In <emphasis>double-quote-mode</emphasis>:</para>
<orderedlist>
<listitem><para>A double quote (<code>"</code>) is added to the current expression and
the parser moves to <emphasis>xpath-mode</emphasis>.</para></listitem>
<listitem><para>All other characters are appended to the current expression.</para></listitem>
</orderedlist>
</listitem>
</itemizedlist>

<para><error code="C0067">It is a <glossterm>dynamic error</glossterm> if the parser reaches
the end of the unit of content and it is not in <emphasis>regular-mode</emphasis>.</error>
</para>

<para>The context node used for each expression is the document passed on the
<port>source</port> port.
<error code="C0068">It is a <glossterm>dynamic error</glossterm>
if more than one document appears on the <port>source</port> port.</error>
In an XPath 1.0 implementation, if
<tag>p:empty</tag> is given or implied on the <port>source</port> port, an
empty document node is used as
the context node. In an XPath 2.0 implementation, the context item is
undefined.
<error code="C0026">It is a <glossterm>dynamic error</glossterm> if
any XPath expression makes reference to the context node, size, or
position when the context item is undefined.</error></para>

<para>In an attribute value, processing instruction, or comment, the
string value of the XPath expression is used. In text content, an
expression that selects nodes will cause those nodes to be copied into
the template document.</para>

<note xml:id="note-xpath-version">
<para>Depending on which version of XPath an implementation supports,
and possibly on the <tag class="attribute">xpath-version</tag> setting on
the <tag>p:template</tag>, some implementations may report errors, or
different results, than other implementations in those cases where the
interpretation of an XPath expression differs between the versions of
XPath.</para>
</note>

<section xml:id="ex-template" role="tocsuppress">
<title>Example</title>

<para>It's quite common to construct documents using values computed
by the pipeline. This is particularly (but not exclusively) the case
when the pipeline uses the <tag>p:http-request</tag> step. The input
to <tag>p:http-request</tag> is a <tag>c:request</tag> document;
attributes on the <tag>c:request</tag> element control most of the
request parameters; the body of the document forms the body of
request.</para>

<para>A typical example looks like this:</para>

<programlisting>&lt;c:request method="POST" href="http://example.com/post"
           username="user" password="password"&gt;
&lt;c:body&gt;
  &lt;computed-content/&gt;
&lt;/c:body&gt;
&lt;/c:request&gt;</programlisting>

<para>If we assume that the <tag class="attribute">href</tag> value and the computed
content come from an input document, and the username and password are options, then a
typical pipeline to compute the request becomes quite complex.</para>

<programlisting>&lt;p:declare-step xmlns:p="http://www.w3.org/ns/xproc"
                xmlns:c="http://www.w3.org/ns/xproc-step"
                name="main" version="3.0"&gt;
&lt;p:input port="source"/&gt;
&lt;p:output port="result"/&gt;
&lt;p:option name="username" required="true"/&gt;
&lt;p:option name="password" required="true"/&gt;

&lt;p:identity&gt;
  &lt;p:with-input port="source"&gt;
    &lt;c:request method="POST"/&gt;
  &lt;/p:with-input&gt;
&lt;/p:identity&gt;

&lt;p:add-attribute match="/c:request" attribute-name="href"&gt;
  &lt;p:with-option name="attribute-value" select="/doc/request/@uri"&gt;
    &lt;p:pipe step="main" port="source"/&gt;
  &lt;/p:with-option&gt;
&lt;/p:add-attribute&gt;

&lt;p:add-attribute match="/c:request" attribute-name="username"&gt;
  &lt;p:with-option name="attribute-value" select="$username"/&gt;
&lt;/p:add-attribute&gt;

&lt;p:add-attribute match="/c:request" attribute-name="password"&gt;
  &lt;p:with-option name="attribute-value" select="$password"/&gt;
&lt;/p:add-attribute&gt;

&lt;p:insert position="first-child" match="/c:request"&gt;
  &lt;p:with-input port="insertion" select="/doc/request"&gt;
    &lt;p:pipe step="main" port="source"/&gt;
  &lt;/p:with-input&gt;
&lt;/p:insert&gt;

&lt;p:unwrap match="/c:request/request"/&gt;

&lt;/p:declare-step&gt;</programlisting>

<para>There's nothing wrong with this pipeline, but it requires
several steps to accomplish with the pipeline author probably
considers a single operation. What's more, the result of these steps
is not immediately obvious on casual inspection.</para>

<para>In order to make this simple construction case both literally
and conceptually simpler, this note introduces two new XProc steps in
the XProc namespace. Support for these steps is optional, but we
strongly encourage implementors to provide them.</para>

<para>The new steps are <tag>p:in-scope-names</tag> and
<tag>p:template</tag>. Taken together, they greatly simplify
the pipeline:</para>

<programlisting>&lt;p:declare-step xmlns:p="http://www.w3.org/ns/xproc"
                xmlns:c="http://www.w3.org/ns/xproc-step"
                name="main" version="3.0"&gt;
&lt;p:input port="source"/&gt;
&lt;p:output port="result"/&gt;
&lt;p:option name="username" required="true"/&gt;
&lt;p:option name="password" required="true"/&gt;

&lt;!-- FIXME: this exmaple doesn't work anymore --&gt;

&lt;p:in-scope-names name="vars"/&gt;

&lt;p:template&gt;
  &lt;p:with-input port="template"&gt;
    &lt;p:inline&gt;
      &lt;c:request method="POST" href="{/doc/request/@uri}"
                 username="{$username}" password="{$password}"&gt;
        { /doc/request/node() }
      &lt;/c:request&gt;
    &lt;/p:inline&gt;
  &lt;/p:with-input&gt;
  &lt;p:with-input port="source" pipe="main@source"/&gt;
  &lt;!--
  &lt;p:input port="parameters"&gt;
    &lt;p:pipe step="vars" port="result"/&gt;
  &lt;/p:input&gt;
  --&gt;
&lt;/p:template&gt;

&lt;/p:declare-step&gt;</programlisting>

<para>The <tag>p:in-scope-names</tag> step provides all of the in-scope options and variables
in a <tag>c:param-set</tag> (this operation is exactly analagous to what the
<tag>p:parameters</tag> step does, except that it operates on the options and variables instead
of on parameters).</para>

<para>The <tag>p:template</tag> step searches for XPath
expressions, delimited by curly braces, in a template document and replaces each with the
result of evaluating the expression. All of the parameters passed to the
<tag>p:template</tag> step are available as in-scope variable names when evaluating
each XPath expression.</para>

<para>Where the expressions occur in attribute values, their string value is used. Where
they appear in text content, their node values are used.</para>

</section>

<section>
<title>Document properties</title>
<para feature="template-preserves-none">No document properties are preserved.</para>
</section>
</section>
<section xml:id="c.uuid">
<title>p:uuid</title>

<para>The <tag>p:uuid</tag> step generates a
<biblioref linkend="bib.uuid"/> and injects it into
the <port>source</port> document.</para>

<p:declare-step type="p:uuid">
  <p:input port="source" primary="true" content-types="application/xml text/xml */*+xml"/>
  <p:output port="result" content-types="application/xml"/>
  <p:option name="match" select="'/*'" as="xs:string" e:type="XSLTMatchPattern"/>
  <p:option name="version" as="xs:integer"/>
</p:declare-step>

<para>The value of the <option>match</option> option must be an
XSLTMatchPattern. The value of the <option>version</option> option
must be an integer.</para>

<para>If the <option>version</option> is specified, that version of
UUID must be computed. <error code="C0060">It is a <glossterm>dynamic
error</glossterm> if the processor does not support the specified
<option>version</option> of the UUID algorithm.</error> <impl>If the
<option>version</option> is not specified, the version of UUID
computed is
<glossterm>implementation-defined</glossterm>.</impl></para>

<para>Implementations <rfc2119>must</rfc2119> support version 4 UUIDs.
<impl>Support for other versions of UUID, and the mechanism by which
the necessary inputs are made available for computing other versions,
is <glossterm>implementation-defined</glossterm>.</impl>
</para>

<para>The matched nodes are specified with the match pattern in the
<option>match</option> option. For each matching node, the generated
UUID is used in the output (if more than one node matches, the
<emphasis>same</emphasis> UUID is used in each match). Nodes that do not
match are copied without change.</para>

<para>If the expression given in the <option>match</option> option
matches an <emphasis>attribute</emphasis>, the UUID is used as the new
value of the attribute in the output. If the attribute is named “<tag class="attribute">xml:base</tag>”, the base URI of the element
<rfc2119>must</rfc2119> also be amended accordingly.</para>

<para>If the expression matches any
other kind of node, the entire node (and <emphasis>not</emphasis> just
its contents) is replaced by the UUID.</para>

<section>
<title>Document properties</title>
<para feature="uuid-preserves-all">All document properties are preserved.</para>
</section>
</section>
<section xml:id="c.validate-with-relax-ng">
<title>p:validate-with-relax-ng</title>

<para>The <tag>p:validate-with-relax-ng</tag> step applies
<biblioref linkend="iso19757-2"/>
validation to the <port>source</port> document.</para>

<p:declare-step type="p:validate-with-relax-ng">
  <p:input port="source" primary="true" content-types="application/xml text/xml */*+xml"/>
  <p:input port="schema" content-types="application/xml */*+xml text/*"/>
  <p:output port="result" content-types="application/xml"/>
  <p:option name="dtd-attribute-values" select="false()" as="xs:boolean"/>
  <p:option name="dtd-id-idref-warnings" select="false()" as="xs:boolean"/>
  <p:option name="assert-valid" select="true()" as="xs:boolean"/>
</p:declare-step>

<para>The values of the <option>dtd-attribute-values</option> and
<option>dtd-id-idref-warnings</option> options
<rfc2119>must</rfc2119> be booleans.</para>

<para>If the <port>schema</port> document has an XML media type, then
it <rfc2119>must</rfc2119> be interpreted as a RELAX NG Grammar. If
the <port>schema</port> document has the media type
“<literal>application/relax-ng-compact-syntax</literal>” or the media
type has a “<literal>text</literal>” type, then it
<rfc2119>must</rfc2119> be interpreted as a <biblioref linkend="relaxng-compact-syntax"/> document for validation.</para>

<para>If the <option>dtd-attribute-values</option> option is
<literal>true</literal>, then the attribute value defaulting conventions of
<biblioref linkend="relaxng-dtd-compat"/> are also applied.</para>

<para>If the <option>dtd-id-idref-warnings</option> option is
<literal>true</literal>, then the validator <rfc2119>should</rfc2119>
treat a schema that is incompatible with the ID/IDREF/IDREFs feature
of <biblioref linkend="relaxng-dtd-compat"/> as if the document
was invalid.
</para>

<para><error code="C0053">It is a <glossterm>dynamic error</glossterm>
if the <option>assert-valid</option> option is <literal>true</literal>
and the input document is not valid.</error></para>

<para>The output from this step is a copy of the input, possibly
augmented by application of the
<biblioref linkend="relaxng-dtd-compat"/>. The output of this step
<rfc2119>may</rfc2119> include PSVI annotations.</para>

<para><impl>Support for <biblioref linkend="relaxng-dtd-compat"/> is
<glossterm>implementation defined</glossterm>.</impl></para>

<section>
<title>Document properties</title>
<para feature="validate-with-relax-ng-preserves-all">All document properties on
the <port>source</port> port are preserved on the <port>result</port> port.
No document properties on the <port>schemas</port> port are preserved.</para>
</section>
</section>
<section xml:id="c.validate-with-schematron">
<title>p:validate-with-schematron</title>

<para>The <tag>p:validate-with-schematron</tag> step applies
<biblioref linkend="iso19757-3"/>
processing to the <port>source</port> document.</para>

<p:declare-step type="p:validate-with-schematron">
  <p:input port="source" primary="true" content-types="application/xml text/xml */*+xml"/>
  <p:input port="schema" content-types="application/xml text/xml */*+xml"/>
  <p:output port="result" primary="true" content-types="application/xml"/>
  <p:output port="report" sequence="true" content-types="application/xml"/>
  <p:option name="parameters" as="map(xs:QName,item())"/>
  <p:option name="phase" select="'#ALL'" as="xs:string"/>
  <p:option name="assert-valid" select="true()" as="xs:boolean"/>
</p:declare-step>

<para><error code="C0054">It is a <glossterm>dynamic error</glossterm>
if the <option>assert-valid</option> option is <literal>true</literal>
and any Schematron assertions fail.</error></para>

<para>The value of the <option>phase</option> option identifies the
Schematron validation phase with which validation begins.</para>

<para>The <option>parameters</option> option provides name/value pairs which
correspond to Schematron external variables.</para>

<para>The <port>result</port> output from this step is a copy of the
input.</para>

<para>Schematron assertions and reports, if any,
<rfc2119>must</rfc2119> appear on the <port>report</port> port. The
output <rfc2119>should</rfc2119> be in <citetitle>Schematron
Validation Report Language</citetitle> (SVRL).</para>

<para>The output of this step
<rfc2119>may</rfc2119> include PSVI annotations.</para>

<section>
<title>Document properties</title>
<para feature="validate-with-schematron-preserves-all">All document properties
on the <port>source</port> port are preserved on the <port>result</port> port.
No document properties on the <port>schemas</port> port are preserved. No document
properties are preserved on the <port>report</port> port.</para>
</section>
</section>
<section xml:id="c.validate-with-xml-schema">
<title>p:validate-with-xml-schema</title>

<para>The <tag>p:validate-with-xml-schema</tag> step applies
<biblioref linkend="xmlschema-1"/>
validity assessment to the <port>source</port> input.</para>

<p:declare-step type="p:validate-with-xml-schema">
  <p:input port="source" primary="true" content-types="application/xml text/xml */*+xml"/>
  <p:input port="schema" sequence="true" content-types="application/xml text/xml */*+xml"/>
  <p:output port="result" content-types="application/xml"/>
  <p:option name="use-location-hints" select="false()" as="xs:boolean"/>
  <p:option name="try-namespaces" select="false()" as="xs:boolean"/>
  <p:option name="assert-valid" select="true()" as="xs:boolean"/>
  <p:option name="mode" select="'strict'" as="xs:token" e:type="strict|lax"/>
  <p:option name="version" as="xs:string"/>
</p:declare-step>

<para>The values of the <option>use-location-hints</option>,
<option>try-namespaces</option>, and
<option>assert-valid</option>
options
 <rfc2119>must</rfc2119> be boolean.</para>

<para>The value of the <option>mode</option> option
<rfc2119>must</rfc2119> be an NMTOKEN whose value is either
“<literal>strict</literal>” or “<literal>lax</literal>”.</para>

<para>Validation is performed against the set of schemas represented
by the documents on the <port>schema</port> port. These schemas must
be used in preference to any schema locations provided by schema
location hints encountered during schema validation, that is, schema
locations supplied for <code>xs:import</code> or
<code>xsi:schema-location</code>, or determined by
schema-processor-defined namespace-based strategies, for the
namespaces covered by the documents available on the schemas port.</para>

<para>If <code>xs:include</code> elements occur within the supplied
schema documents, they are treated like any other
<olink targetdoc="../xproc20/xproc20.xml" targetptr="external-docs">external
documents</olink>. <impl>It is
<glossterm>implementation-defined</glossterm> if the documents supplied
on the <port>schemas</port> port are considered when resolving
<code>xs:include</code> elements in the schema documents provided.</impl>
</para>

<para>The <option>use-location-hints</option> and
<option>try-namespaces</option> options allow the pipeline author to
control how the schema processor should attempt to locate schema
documents necessary but not provided on the <port>schema</port>
port. Any schema documents provided on the <port>schema</port> port
<rfc2119>must</rfc2119> be used in preference to schema documents
located by other means.</para>

<para>If the <option>use-location-hints</option> option is
“<literal>true</literal>”, the processor <rfc2119>should</rfc2119>
make use of schema location hints to locate schema documents. If the
option is “<literal>false</literal>”, the processor
<rfc2119>should</rfc2119> ignore any such hints.</para>

<para>If the <option>try-namespaces</option> option is
“<literal>true</literal>”, the processor <rfc2119>should</rfc2119>
attempt to dereference the namespace URI to locate schema documents.
If the
option is “<literal>false</literal>”, the processor
<rfc2119>should not</rfc2119> dereference namespace URIs.</para>

<para>The <option>mode</option> option allow the pipeline author to
control how schema validation begins. The “<literal>strict</literal>”
mode means that the document element must be declared and
schema-valid, otherwise it will be treated as invalid. The
“<literal>lax</literal>” mode means that the
absence of a declaration for the document element does not itself
count as an unsuccessful outcome of validation.</para>

<para>If the step specifies a <option>version</option>, then that version
of XML Schema <rfc2119>must</rfc2119> be used to process the validation.
<error code="C0038">It is a
<glossterm>dynamic error</glossterm> if the specified version
is not available.</error> If the step does not specify a version, the
implementation may use any version it has available and may use any means
to determine what version to use, including, but not limited to,
examining the version of the schema(s).</para>

<para><error code="C0053">It is a <glossterm>dynamic error</glossterm>
if the <option>assert-valid</option> option is <literal>true</literal>
and the input document is not valid.</error> If the <option>assert-valid</option>
option is <literal>false</literal>, it is not an error for the document
to be invalid. In this case, if the implementation does not
support the PSVI, <tag>p:validate-with-xml-schema</tag> is essentially
just an “identity” step, but if the implementation <emphasis>does</emphasis>
support the PSVI, then the resulting document will have additional type
information (at least for the subtrees that are valid).</para>

<para>When XML Schema validation assessment
is performed, the processor is invoked in the mode specified by the
<option>mode</option> option.
<error code="C0055">It is a <glossterm>dynamic error</glossterm>
if the implementation does not support the specified mode.</error>
</para>

<para>The <port>result</port> of the assessment is a document with the
Post-Schema-Validation-Infoset (PSVI) (<biblioref linkend="xmlschema-1"/>) annotations, if the pipeline implementation
supports such annotations. If not, the input document is reproduced
with any defaulting of attributes and elements performed as specified
by the XML Schema recommendation.</para>

<section>
<title>Document properties</title>
<para feature="validate-with-xml-schema-preserves-all">All document properties
on the <port>source</port> port are preserved on the <port>result</port> port.
No document properties on the <port>schemas</port> port are preserved.</para>
</section>
</section>
<section xml:id="c.www-form-urldecode">
<title>p:www-form-urldecode</title>

<para>The <tag>p:www-form-urldecode</tag> step decodes a
<literal>x-www-form-urlencoded</literal> string into an XML representation.</para>

<p:declare-step type="p:www-form-urldecode">
  <p:output port="result" content-types="application/xml"/>
  <p:option name="value" required="true" as="xs:string"/>
</p:declare-step>

<para>The <option>value</option> option is interpreted as a string of
parameter values encoded using the
<literal>x-www-form-urlencoded</literal> algorithm. Each name/value
pair is written in a <tag>c:param</tag> element.
The entire set of parameters
is written (as a <tag>c:param-set</tag>) on the <port>result</port>
output port.</para>

<para><error code="C0037">It is a
<glossterm>dynamic error</glossterm> if the <option>value</option> provided
is not a properly
<literal>x-www-form-urlencoded</literal> value.</error>
<error code="C0061">It is a
<glossterm>dynamic error</glossterm> if the name of any encoded parameter
name is not a valid <type>xs:NCName</type>.</error> In other words, this
step can only decode simple name/value pairs where the names do not contain
colons or any characters that cannot be used in XML names.
</para>

<para>The order of the <tag>c:param</tag> elements in the result is the same
as the order of the encoded parameters, reading from left to right.</para>

<para>If any parameter name occurs more than once in the encoded string,
the resulting parameter set will contain a <tag>c:param</tag> for
each instance.</para>

<section>
<title>Document properties</title>
<para feature="www-form-urldecode-preserves-none">No document properties are preserved.</para>
</section>
</section>
<section xml:id="c.www-form-urlencode">
<title>p:www-form-urlencode</title>

<para>The <tag>p:www-form-urlencode</tag> step encodes a set of parameter
values as a <literal>x-www-form-urlencoded</literal> string and
injects it into the <port>source</port> document.</para>

<p:declare-step type="p:www-form-urlencode">
  <p:input port="source" primary="true" content-types="application/xml text/xml */*+xml"/>
  <p:output port="result" content-types="application/xml"/>
  <p:option name="parameters" as="map(xs:QName,item())"/>
  <p:option name="match" required="true" as="xs:string" e:type="XSLTMatchPattern"/>
</p:declare-step>

<para>The value of the <option>match</option> option must be an
XSLTMatchPattern.</para>

<para>The set of parameters is encoded as a single
<literal>x-www-form-urlencoded</literal> string of name/value pairs.
When parameters are encoded into name/value pairs,
<emphasis>only</emphasis> the local name of each parameter is used.
The namespace name is ignored and no prefix or colon appears in the name.
</para>

<para><impl>The order of the parameters is
is <glossterm>implementation-dependent</glossterm>.</impl></para>

<para>The matched nodes are specified with the match pattern in the
<option>match</option> option. For each matching node, the encoded
string is used in the output. Nodes that do not
match are copied without change.</para>

<para>If the expression given in the <option>match</option> option
matches an <emphasis>attribute</emphasis>, the encoded
string is used as the new value of the attribute in the output.
If the expression matches any other kind of node, the entire
node (and <emphasis>not</emphasis> just its contents) is replaced by
the encoded string.</para>

<section>
<title>Document properties</title>
<para feature="www-form-urlencode-preserves-none">No document properties are preserved.</para>
</section>
</section>
<section xml:id="c.xquery">
<title>p:xquery</title>

<para>The <tag>p:xquery</tag> step applies an
<biblioref linkend="xquery10"/> query to the sequence of documents
provided on the <port>source</port> port.</para>

<p:declare-step type="p:xquery">
  <p:input port="source" content-types="application/xml text/xml */*+xml" sequence="true" primary="true"/>
  <p:input port="query" content-types="application/xml */*+xml text/*"/>
  <p:output port="result" sequence="true" content-types="*/*"/>
  <p:option name="parameters" as="map(xs:QName,item())"/>
  <p:option name="version" as="xs:string"/>
</p:declare-step>

<para>If a sequence of documents is provided on the
<port>source</port> port, the first document is used as the
initial context item. The whole sequence is also the default
collection. If no documents are provided on the <port>source</port> port,
the initial context item is undefined and the default collection
is empty.</para>

<para>The <port>query</port> port must receive a single document:</para>

<itemizedlist>
<listitem>
<para>If the document root element is <tag xml:id="cv.query">c:query</tag>, the text
descendants of this element are considered the query.</para>
<e:rng-pattern name="VocabQuery"/>
</listitem>

<listitem>
<para>If the document root element is in the XQueryX namespace, the
document is treated as an XQueryX-encoded query. <impl>Support for
XQueryX is <glossterm>implementation-defined</glossterm>.</impl>
</para>
</listitem>

<listitem>
<para>If the <port>query</port> document has an XML media type, then
the string value of the document <rfc2119>must</rfc2119> be treated as
the query. If the media type has a “<literal>text</literal>” type,
then it <rfc2119>must</rfc2119> be interpreted as the query.</para>
</listitem>

<listitem>
<para><impl>Otherwise, the interpretation of the query
is <glossterm>implementation-defined</glossterm>.</impl>
</para>
</listitem>
</itemizedlist>

<para>If the step specifies a <option>version</option>, then that version
of XQuery <rfc2119>must</rfc2119> be used to process the transformation.
<error code="C0038">It is a
<glossterm>dynamic error</glossterm> if the specified version
is not available.</error> If the step does not specify a version, the
implementation may use any version it has available and may use any means
to determine what version to use, including, but not limited to,
examining the version of the query.</para>

<para>The result of the <tag>p:xquery</tag> step must be a sequence of
documents. <error code="C0057">It is a <glossterm>dynamic
error</glossterm> if the sequence that results from evaluating the XQuery contains
items other than documents and elements.</error> Any elements that appear
in the result sequence will be treated as documents with the element as their
document element.</para>

<para>For example:</para>
<programlisting language="xml">
&lt;c:query&gt;
declare namespace atom="http://www.w3.org/2005/Atom";
/atom:feed/atom:entry
&lt;/c:query&gt;

</programlisting>

<para>The output of this step
<rfc2119>may</rfc2119> include PSVI annotations.</para>

<para>The static context of the XQuery processor is augmented in the following
way:</para>

<variablelist>
<varlistentry>
<term>Statically known default collection type</term>
<listitem>
<para><literal>document()*</literal></para>
</listitem>
</varlistentry>
<varlistentry>
<term>Statically known namespaces:</term>
<listitem>
<para>Unchanged from the implementation defaults. No namespace declarations
in the XProc pipeline are automatically exposed in the static context.
</para>
</listitem>
</varlistentry>
</variablelist>

<para>The dynamic context of the XQuery processor is augmented in the following
way:</para>

<variablelist>
<varlistentry>
<term>Context item</term>
<listitem>
<para>The first document that appears on the <port>source</port> port.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Context position</term>
<listitem>
<para><literal>1</literal>
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Context size</term>
<listitem>
<para><literal>1</literal>
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Variable values</term>
<listitem>
<para>Any parameters passed in the <option>parameters</option> option
augment any implementation-defined variable bindings known to the XQuery
processor.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Function implementations</term>
<listitem>
<para>The function implementations provided by the XQuery processor.</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Current dateTime</term>
<listitem>
<para><impl>The point in time returned as the current dateTime is
<glossterm>implementation-defined</glossterm>.</impl></para>
</listitem>
</varlistentry>
<varlistentry>
<term>Implicit timezone</term>
<listitem>
<para><impl>The implicit timezone is <glossterm>implementation-defined</glossterm>.
</impl>
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Available documents</term>
<listitem>
<para><impl>The set of available documents (those that may be retrieved with a URI)
is <glossterm>implementation-dependent</glossterm>.</impl>
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Available collections</term>
<listitem>
<para><impl>The set of available collections
is <glossterm>implementation-dependent</glossterm>.</impl>
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Default collection</term>
<listitem>
<para>The sequence of documents provided on the <port>source</port> port.
</para>
</listitem>
</varlistentry>
</variablelist>

<section xml:id="example-xquery" role="tocsuppress">
<title>Example</title>

<para>The following pipeline applies XInclude processing and schema
validation before using XQuery:</para>

<example xml:id="ex.c.xquery">
<title>A Sample Pipeline Document</title>
<programlisting language="xml">&lt;p:declare-step xmlns:p="http://www.w3.org/ns/xproc"
                version="3.0"&gt;
&lt;p:input port="source"/&gt;
&lt;p:output port="result"/&gt;

&lt;p:xinclude/&gt;

&lt;p:validate-with-xml-schema name="validate"&gt;
  &lt;p:with-input port="schema" href="http://example.com/path/to/schema.xsd"/&gt;
&lt;/p:validate-with-xml-schema&gt;

&lt;p:xquery&gt;
   &lt;p:with-input port="query" href="countp.xq"/&gt;
&lt;/p:xquery&gt;

&lt;/p:declare-step&gt;</programlisting>
</example>

<para>Where <filename>countp.xq</filename> might contain:</para>

<programlisting language="xml">&lt;count&gt;{count(.//p)}&lt;/count&gt;</programlisting>

</section>

<section>
<title>Document properties</title>
<para feature="xquery-preserves-none">No document properties are preserved.</para>
</section>
</section>
<section xml:id="c.xsl-formatter">
<title>p:xsl-formatter</title>

<para>The <tag>p:xsl-formatter</tag> step receives an <biblioref linkend="xsl11"/> document and renders the content. The result of
rendering is stored to the URI provided via the <option>href</option>
option. A reference to that result is produced on the output
port.</para>

<p:declare-step type="p:xsl-formatter">
  <p:input port="source" content-types="application/xml text/xml */*+xml"/>
  <p:output port="result" content-types="*/*"/>
  <p:option name="parameters" as="map(xs:QName,item())"/>
  <p:option name="href" required="true" as="xs:anyURI"/>
  <p:option name="content-type" as="xs:string"/>
</p:declare-step>

<para>The value of the <option>href</option> option
<rfc2119>must</rfc2119> be an <type>anyURI</type>. If it is relative,
it is made absolute against the base URI of the element on which it is
specified (<tag>p:with-option</tag> or <tag>p:xsl-formatter</tag> in the
case of a <olink targetdoc="../xproc20/xproc20.xml" targetptr="option-shortcut">syntactic shortcut</olink>
value).</para>

<para>The content-type of the output is controlled by the
<option>content-type</option> option. This option specifies a media
type as defined by <biblioref linkend="media-types"/>. The option may
include media type parameters as well (e.g.
"application/someformat; charset=UTF-8"). <impl>The use of media type
parameters on the <option>content-type</option> option is
<glossterm>implementation-defined</glossterm>.</impl></para>

<para><impl>If the <option>content-type</option> option is not specified,
the output type is <glossterm>implementation-defined</glossterm>.</impl> The default <rfc2119>should</rfc2119> be
PDF.</para>

<para><impl>A formatter may take any number of optional rendering
parameters via the step's <option>parameters</option>; such parameters
are defined by the XSL implementation used and are
<glossterm>implementation-defined</glossterm>.</impl></para>

<para>The output of this step is a document containing a single
<tag>c:result</tag> element whose content is the absolute URI of the
document stored by the step.</para>

<section>
<title>Document properties</title>
<para feature="xsl-formatter-preserves-none">No document properties are preserved.</para>
</section>
</section>
</section>
</section>

<section xml:id="errors">
<title>Errors</title>
    <para>Errors in a pipeline can be divided into two classes: static errors and dynamic
      errors.</para>
    <section xml:id="static-errors">
      <title>Static Errors</title>
      <para><termdef xml:id="dt-static-error">A <firstterm>static error</firstterm> is one which can
          be detected before pipeline evaluation is even attempted.</termdef> Examples of static
        errors include cycles and incorrect specification of inputs and outputs. </para>
      <para>Static errors are fatal and must be detected before any steps are evaluated.</para>
      <para>For a complete list of static errors, see <xref linkend="app.static-errors"/>.</para>
    </section>
    <section xml:id="dynamic-errors">
      <title>Dynamic Errors</title>
      <para>A <termdef xml:id="dt-dynamic-error">A <firstterm>dynamic error</firstterm> is one which
          occurs while a pipeline is being evaluated.</termdef> Examples of dynamic errors include
        references to URIs that cannot be resolved, steps which fail, and pipelines that exhaust the
        capacity of an implementation (such as memory or disk space).</para>
      <para>If a step fails due to a dynamic error, failure propagates upwards until either a
          <tag>p:try</tag> is encountered or the entire pipeline fails. In other words, outside of a
          <tag>p:try</tag>, step failure causes the entire pipeline to fail.</para>
      <para>For a complete list of dynamic errors, see <xref linkend="app.dynamic-errors"/>.</para>
    </section>
    <section xml:id="step-errors">
      <title>Step Errors</title>
      <para>Several of the steps in the standard and option step library can generate dynamic
        errors.</para>
      <para>For a complete list of the dynamic errors raised by builtin pipeline steps, see <xref linkend="app.step-errors"/>.</para>
    </section>
  </section>
<appendix xml:id="app.step-errors">
<title>Step Errors</title>

<para>The following <glossterm baseform="dynamic-error">dynamic errors</glossterm>
can be raised by steps in this specification:</para>

<?step-error-list?>
</appendix>

<appendix xml:id="credits">
<title>Credits</title>

<para>This document is derived from
<link xlink:href="https://www.w3.org/TR/2010/REC-xproc-20100511/">XProc:
An XML Pipeline Language</link> published by the W3C. It was developed
by the <citetitle>XML Processing Model Working Group</citetitle> and edited by
Norman Walsh, Alex Miłowski, and Henry Thompson.</para>

<para>The editors of this specification extend their gratitude to everyone
who contributed to this document and all of the versions that came before it.</para>
</appendix>

<appendix xml:id="references" version="5.0-extension w3c-xproc">

<title>References</title>

<section xml:id="normative-references">
<title>Normative References</title>

<bibliolist>
<bibliomixed xml:id="use-cases"><abbrev>XProc V2.0 Requirements</abbrev>
<citetitle xlink:href="http://www.w3.org/TR/xproc-v2-req/">XProc V2.0
Requirements</citetitle>.
Alex Milowski, James Fuller, and Norman Walsh editors.
W3C Working Draft 5 November 2013.
</bibliomixed>

<bibliomixed xml:id="xproc20"><abbrev>XProc 2.0</abbrev>
<citetitle xlink:href="http://www.w3.org/TR/xproc20/">XProc 2.0:
An XML Pipeline Language</citetitle>.
Norman Walsh, Alex Milowski, and Henry Thompson, editors.
W3C Working Draft 15 December 2014.
</bibliomixed>

<bibliomixed xml:id="xml-infoset-rec"><abbrev>Infoset</abbrev>
<citetitle xlink:href="http://www.w3.org/TR/xml-infoset/">XML
Information Set (Second Edition)</citetitle>. John Cowan,
Richard Tobin, editors. W3C Working Group Note 04 February 2004.
</bibliomixed>

<bibliomixed xml:id="xml10"><abbrev>XML 1.0</abbrev>
<citetitle xlink:href="http://www.w3.org/TR/REC-xml/">Extensible
Markup Language (XML) 1.0 (Fifth Edition)</citetitle>. Tim Bray,
Jean Paoli, C. M. Sperberg-McQueen, et. al.
editors. W3C Recommendation 26 November 2008.</bibliomixed>

<bibliomixed xml:id="xmlns10"><abbrev>Namespaces 1.0</abbrev>
<citetitle xlink:href="http://www.w3.org/TR/REC-xml-names/">Namespaces
in XML 1.0 (Third Edition)</citetitle>. Tim Bray,
Dave Hollander, Andrew Layman, et. al.,
editors. W3C Recommendation 8 December 2009.</bibliomixed>

<bibliomixed xml:id="xml11"><abbrev>XML 1.1</abbrev>
<citetitle xlink:href="http://www.w3.org/TR/xml11/">Extensible
Markup Language (XML) 1.1 (Second Edition)</citetitle>. Tim Bray,
Jean Paoli, C. M. Sperberg-McQueen, et. al.
editors. W3C Recommendation 16 August 2006.</bibliomixed>

<bibliomixed xml:id="xmlns11"><abbrev>Namespaces 1.1</abbrev>
<citetitle xlink:href="http://www.w3.org/TR/xml-names11/">Namespaces
in XML 1.1 (Second Edition)</citetitle>. Tim Bray,
Dave Hollander, Andrew Layman, et. al.,
editors. W3C Recommendation 16 August 2006.</bibliomixed>

<bibliomixed xml:id="xslt10"><abbrev>XSLT 1.0</abbrev>
<citetitle xlink:href="http://www.w3.org/TR/xslt">XSL Transformations (XSLT)
Version 1.0</citetitle>. James Clark, editor.
W3C Recommendation. 16 November 1999.</bibliomixed>

<bibliomixed xml:id="lastcall-xslt30"><abbrev>XSLT 3.0</abbrev>
   <citetitle xlink:href="http://www.w3.org/TR/xslt-30/">XSL Transformations (XSLT) Version 3.0</citetitle>. Michael Kay,
   W3C Last Call Working Draft 2 October 2014</bibliomixed>
   
<bibliomixed xml:id="xpath31"><abbrev>XPath 3.1</abbrev>
<citetitle xlink:href="http://www.w3.org/TR/xpath31/">XML Path Language (XPath)
	3.1</citetitle>. Jonathan Robie, Michael Dyck, Josh Spiegel, editors.
W3C Recommendation. 21 March 2017.</bibliomixed>

<bibliomixed xml:id="xpath2"><abbrev>XPath 2.0</abbrev>
<citetitle xlink:href="http://www.w3.org/TR/xpath20/">XML Path Language (XPath)
2.0</citetitle>. Anders Berglund, Scott Boag, Don Chamberlin, et. al., editors.
W3C Recommendation. 23 January 2007.</bibliomixed>

<bibliomixed xml:id="xpath-datamodel"><abbrev>XQuery 1.0 and XPath 2.0 Data
Model (XDM)</abbrev>
<citetitle xlink:href="http://www.w3.org/TR/xpath-datamodel/">XQuery 1.0 and
XPath 2.0 Data Model (XDM)</citetitle>.
Mary Fernández, Ashok Malhotra, Jonathan Marsh, <foreignphrase>et. al.</foreignphrase>, editors.
W3C Recommendation. 23 January 2007.</bibliomixed>

<bibliomixed xml:id="xpath-functions"><abbrev>XPath and XQuery
Functions and Operators 3.1</abbrev>
<citetitle xlink:href="https://www.w3.org/TR/xpath-functions-31/">XPath and XQuery
Functions and Operators 3.1</citetitle>.
Michael Kay, editors
W3C Recommendation. 21 March 2017.</bibliomixed>

<bibliomixed xml:id="xslt20"><abbrev>XSLT 2.0</abbrev>
<citetitle xlink:href="http://www.w3.org/TR/xslt20/">XSL Transformations (XSLT)
Version 2.0</citetitle>. Michael Kay, editor.
W3C Recommendation. 23 January 2007.</bibliomixed>

<bibliomixed xml:id="xsl11"><abbrev>XSL 1.1</abbrev>
<citetitle xlink:href="http://www.w3.org/TR/xsl/">Extensible Stylesheet
Language (XSL) Version 1.1</citetitle>.
Anders Berglund, editor. W3C Recommendation. 5 December 2006.</bibliomixed>

<bibliomixed xml:id="xquery10"><abbrev>XQuery 1.0</abbrev>
<citetitle xlink:href="http://www.w3.org/TR/xquery/">XQuery 1.0: An XML
Query Language</citetitle>. Scott Boag, Don Chamberlin, Mary Fernández, et. al.,
editors. W3C Recommendation. 23 January 2007.</bibliomixed>

<bibliomixed xml:id="iso19757-2"><abbrev>RELAX NG</abbrev>ISO/IEC JTC 1/SC 34.
<citetitle xlink:href="http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=52348">ISO/IEC 19757-2:2008(E)
Document Schema Definition Language (DSDL) -- Part 2:
Regular-grammar-based
validation -- RELAX NG</citetitle>
2008.
</bibliomixed>

<bibliomixed xml:id="relaxng-compact-syntax"><abbrev>RELAX NG
Compact Syntax</abbrev>ISO/IEC JTC 1/SC 34.
<citetitle>ISO/IEC 19757-2:2003/Amd 1:2006 Document Schema Definition
Languages (DSDL) — Part 2: Grammar-based validation — RELAX NG AMENDMENT 1
Compact Syntax</citetitle>
2006.
</bibliomixed>

<bibliomixed xml:id="relaxng-dtd-compat"><abbrev>RELAX NG DTD Compatibility</abbrev>
<citetitle>RELAX NG DTD Compatibility</citetitle>.
OASIS Committee Specification.
3 December 2001.
</bibliomixed>

<bibliomixed xml:id="iso19757-3"><abbrev>Schematron</abbrev>ISO/IEC JTC 1/SC 34.
<citetitle>ISO/IEC 19757-3:2006(E) Document Schema Definition
Languages (DSDL) — Part 3: Rule-based validation — Schematron</citetitle>
2006.
</bibliomixed>

<bibliomixed xml:id="xmlschema-1"><abbrev>W3C XML Schema: Part 1</abbrev>
<citetitle xlink:href="http://www.w3.org/TR/xmlschema-1/">XML Schema Part 1:
Structures Second Edition</citetitle>.
Henry S. Thompson, David Beech, Murray Maloney, et. al., editors.
World Wide Web Consortium, 28 October 2004.
</bibliomixed>

<bibliomixed xml:id="xmlschema-2"><abbrev>W3C XML Schema: Part 2</abbrev>
<citetitle xlink:href="http://www.w3.org/TR/xmlschema-2/">XML Schema Part 2:
Datatypes Second Edition</citetitle>.
Paul V. Biron and Ashok Malhotra, editors.
World Wide Web Consortium, 28 October 2004.
</bibliomixed>

<bibliomixed xml:id="xml-id"><abbrev>xml:id</abbrev>
<citetitle xlink:href="http://www.w3.org/TR/xml-id/">xml:id
Version 1.0</citetitle>. Jonathan Marsh, Daniel Veillard, and Norman Walsh, editors.
W3C Recommendation. 9 September 2005.</bibliomixed>

<bibliomixed xml:id="xinclude"><abbrev>XInclude</abbrev>
<citetitle xlink:href="http://www.w3.org/TR/xinclude/">XML Inclusions
(XInclude) Version 1.0 (Second Edition)</citetitle>. Jonathan Marsh,
David Orchard, and Daniel Veillard, editors.
W3C Recommendation. 15 November 2006.</bibliomixed>

<bibliomixed xml:id="xml-base"><abbrev>XML Base</abbrev>
<citetitle xlink:href="http://www.w3.org/TR/xmlbase/">XML Base
(Second Edition)</citetitle>.
Jonathan Marsh and Richard Tobin, editors.
W3C Recommendation. 28 January 2009.</bibliomixed>

<bibliomixed xml:id="xptr-framework"><abbrev>XPointer Framework</abbrev>
<citetitle xlink:href="http://www.w3.org/TR/xptr-framework/">XPointer Framework</citetitle>.
Paul Grosso, Eve Maler, Jonathan Marsh, et. al., editors.
W3C Recommendation. 25 March 2003.</bibliomixed>

<bibliomixed xml:id="xptr-element"><abbrev>XPointer element() Scheme</abbrev>
<citetitle xlink:href="http://www.w3.org/TR/xptr-element/">XPointer element() Scheme</citetitle>.
Paul Grosso, Eve Maler, Jonathan Marsh, et. al., editors.
W3C Recommendation. 25 March 2003.</bibliomixed>

<bibliomixed xml:id="xml-serialization"><abbrev>Serialization</abbrev>
<citetitle xlink:href="http://www.w3.org/TR/xslt-xquery-serialization/">XSLT 2.0 and XQuery 1.0 Serialization</citetitle>.
 Scott Boag, Michael Kay, Joanne Tong, Norman Walsh, and Henry Zongaro, editors.  W3C Recommendation. 23 January 2007.</bibliomixed>

<bibliomixed xml:id="rfc1321"><abbrev>MD5</abbrev>
<citetitle xlink:href="http://www.ietf.org/rfc/rfc1321.txt">RFC 1321:
The MD5 Message-Digest Algorithm</citetitle>.
R. Rivest. Network Working Group, IETF, April 1992.</bibliomixed>

<bibliomixed xml:id="rfc1521"><abbrev>RFC 1521</abbrev>
<citetitle xlink:href="http://www.ietf.org/rfc/rfc1521.txt">RFC 1521:
MIME (Multipurpose Internet Mail Extensions) Part One: Mechanisms for
Specifying and Describing the Format of Internet Message
Bodies</citetitle>. N. Borenstein, N. Freed, editors. Internet
Engineering Task Force. September, 1993.</bibliomixed>

<bibliomixed xml:id="rfc2119"><abbrev>RFC 2119</abbrev>
<citetitle xlink:href="http://www.ietf.org/rfc/rfc2119.txt">Key words for use in RFCs to Indicate Requirement Levels</citetitle>.
S. Bradner.
Network Working Group, IETF,
Mar 1997.
</bibliomixed>

<bibliomixed xml:id="rfc2396"><abbrev>RFC 2396</abbrev>
<citetitle xlink:href="http://www.ietf.org/rfc/rfc2396.txt">Uniform Resource Identifiers (URI): Generic Syntax</citetitle>.
T. Berners-Lee, R. Fielding, and L. Masinter.
Network Working Group, IETF,
Aug 1998.
</bibliomixed>

<bibliomixed xml:id="rfc2616"><abbrev>RFC 2616</abbrev>
<citetitle xlink:href="http://www.ietf.org/rfc/rfc2616.txt">RFC 2616:
Hypertext Transfer Protocol — HTTP/1.1</citetitle>.
R. Fielding, J. Gettys, J. Mogul, et. al., editors. Internet
Engineering Task Force. June, 1999.</bibliomixed>

<bibliomixed xml:id="rfc2617"><abbrev>RFC 2617</abbrev>
<citetitle xlink:href="http://www.ietf.org/rfc/rfc2617.txt">RFC 2617:
HTTP Authentication: Basic and Digest Access Authentication</citetitle>.
J. Franks, P. Hallam-Baker, J. Hostetler, S. Lawrence, P. Leach, A. Luotonen, L. Stewart. June, 1999
.</bibliomixed>

<bibliomixed xml:id="rfc3023"><abbrev>RFC 3023</abbrev>
<citetitle xlink:href="http://www.ietf.org/rfc/rfc3023.txt">RFC 3023:
XML Media Types</citetitle>.
M. Murata, S. St. Laurent, and D. Kohn, editors. Internet
Engineering Task Force. January, 2001.</bibliomixed>

<bibliomixed xml:id="rfc3548"><abbrev>RFC 3548</abbrev>
<citetitle xlink:href="http://www.ietf.org/rfc/rfc3548.txt">RFC 3548:
The Base16, Base32, and Base64 Data Encodings</citetitle>.
S. Josefsson, Editor. Internet
Engineering Task Force. July, 2003.</bibliomixed>

<bibliomixed xml:id="rfc3986"><abbrev>RFC 3986</abbrev>
<citetitle xlink:href="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986:
Uniform Resource Identifier (URI): General Syntax</citetitle>.
T. Berners-Lee, R. Fielding, and L. Masinter, editors.
Internet Engineering Task Force. January, 2005.</bibliomixed>

<bibliomixed xml:id="rfc3987"><abbrev>RFC 3987</abbrev>
<citetitle xlink:href="http://www.ietf.org/rfc/rfc3987.txt">RFC 3987:
Internationalized Resource Identifiers (IRIs)</citetitle>.
M. Duerst and M. Suignard, editors.
Internet Engineering Task Force. January, 2005.</bibliomixed>

<bibliomixed xml:id="rfc2046"><abbrev>Media Types</abbrev>
<citetitle xlink:href="http://www.ietf.org/rfc/rfc2046.txt">RFC 2046:
Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types</citetitle>.
N. Freed, et. al.. Network Working Group, IETF,
November, 1996.</bibliomixed>

<bibliomixed xml:id="unicodetr17"><abbrev>Unicode TR#17</abbrev>
<citetitle xlink:href="http://unicode.org/reports/tr17/">Unicode Technical
Report #17: Character Encoding Model</citetitle>.
Ken Whistler, Mark Davis, and Asmus Freytag, authors.
The Unicode Consortium. 11 November 2008.</bibliomixed>

<bibliomixed xml:id="media-types"><abbrev>IANA Media Types</abbrev>
<citetitle xlink:href="http://www.iana.org/assignments/media-types/">IANA MIME Media Types</citetitle>. Internet Engineering Task Force.
</bibliomixed>

<bibliomixed xml:id="tidy"><abbrev>HTML Tidy</abbrev>
<citetitle xlink:href="http://tidy.sourceforge.net/">HTML Tidy Library
Project</citetitle>. SourceForge project.
</bibliomixed>

<bibliomixed xml:id="tagsoup"><abbrev>TagSoup</abbrev>
<citetitle xlink:href="http://ccil.org/~cowan/XML/tagsoup/">TagSoup - Just Keep On Truckin'</citetitle>.
John Cowan.
</bibliomixed>

<bibliomixed xml:id="bib.uuid"><abbrev>UUID</abbrev>
<citetitle xlink:href="http://www.itu.int/ITU-T/studygroups/com17/oid.html">ITU
X.667: Information technology - Open Systems Interconnection -
Procedures for the operation of OSI Registration Authorities:
Generation and registration of Universally Unique Identifiers (UUIDs)
and their use as ASN.1 Object Identifier components</citetitle>.
2004.</bibliomixed>

<bibliomixed xml:id="bib.sha"><abbrev>SHA1</abbrev>
<citetitle xlink:href="http://www.itl.nist.gov/fipspubs/fip180-1.htm">Federal Information Processing Standards Publication 180-1: Secure Hash Standard</citetitle>.
1995.</bibliomixed>

</bibliolist>
</section>

<section xml:id="informative-references">
<title>Informative References</title>

<bibliolist>
<bibliomixed xml:id="rfc4122"><abbrev>RFC 4122</abbrev>
<citetitle xlink:href="http://www.ietf.org/rfc/rfc4122.txt">RFC 4122:
A Universally Unique IDentifier (UUID) URN Namespace</citetitle>.
P. Leach and M. Mealling, editors.
Internet Engineering Task Force. July, 2005.</bibliomixed>

<bibliomixed xml:id="bib.crc"><abbrev>CRC32</abbrev>
“32-Bit Cyclic Redundancy Codes for Internet Applications”,
<citetitle>The International Conference on Dependable Systems and Networks:
459</citetitle>. <biblioid class="doi">10.1109/DSN.2002.1028931</biblioid>.
P. Koopman. June 2002.
</bibliomixed>
</bibliolist>
</section>
</appendix>
</specification>